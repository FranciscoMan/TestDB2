-- ================================================================
-- Proyecto: Plaskolite v2
-- Copyright (c) - Vitek - 2019
-- Author: Jose Donaldo Luna, Aideé Alvarez
-- CREATE date: 08/15/2019
-- Description: GET SHIFT REPORT V.2 (DATE AND SHIFT)
-- =================================================================
-- 01/08/2020 : Little changes in joins. by AA
-- 01/28/2020 : Now, best foreman in shift was added. by AA
-- 07/28/2020 : fix running time   by dellc 
-- 10/06/2020 : Little changes. Now you can search reports by plants. AA
-- =================================================================
CREATE PROCEDURE   [PRD].[SPE_GET_SHIFT_REPORT_V2]
	  @ENDT DATETIME, -- DATA REQUIRED
      @KYSHIFT VARCHAR(1200),  -- DATA REQUIRED
	  @BP INT
AS
BEGIN
	DECLARE
	    --@ENDT DATETIME,
	    --@KYSHIFT VARCHAR(200),
		@INIT DATETIME,
		-- especifica el turno 1 que inicia a las 00 horas de la madrugada
		--@TURNO_SF1_INIT DATETIME = (SELECT INITIAL_SHIFT_TIME FROM ADM.VW_C_SHIFT WHERE KY_SHIFT = 'SF-1'), 
		--@TURNO_SF1_FINAL DATETIME = (SELECT FINAL_SHIFT_TIME FROM ADM.VW_C_SHIFT WHERE KY_SHIFT = 'SF-1'), 
		-- especifica el turno 2 que inicia a las 12 horas de la tarde
		--@TURNO_SF2_INIT DATETIME = (SELECT INITIAL_SHIFT_TIME FROM ADM.VW_C_SHIFT WHERE KY_SHIFT = 'SF-2'), 
		--@TURNO_SF2_FINAL DATETIME = (SELECT FINAL_SHIFT_TIME FROM ADM.VW_C_SHIFT WHERE KY_SHIFT = 'SF-2'),
		-- ////
		@FECHA_FINAL DATETIME,
		@WEIGHT DECIMAL(13,2),
		@FECHA_GENERACION_REPORTE DATE = CONVERT(DATE, GETDATE()),
		@VALUE_PRODUCED_TOTAL DECIMAL(10,2),
		@VALUE_GROSS_LINE DECIMAL(10,2),
		@TOTAL_SHIFT_SAVING DECIMAL(10,2),
		@COUNTER INT,
		@COUNT_FOREMAN INT,
		@NM_FOREMAN VARCHAR(80)
		 --SET @ENDT = GETDATE()  -- Fecha de prueba: '2019-03-07', 2019-07-12 o getdate()[del día]
		 --SET @KYSHIFT = 'SF-2'
		
		--IF (@KYSHIFT = 'SF-1') 
		--BEGIN
		--SET @INIT = DATEADD(HOUR, 0, @ENDT)
		--(SELECT @FECHA_FINAL = CONVERT(DATETIME, @ENDT) + CONVERT(DATETIME, @TURNO_SF1_FINAL))
		--END
		--ELSE 
		--BEGIN
		--SET @INIT = DATEADD(HOUR, 12, @ENDT)
		--(SELECT @FECHA_FINAL = CONVERT(DATETIME, @ENDT) + CONVERT(DATETIME, @TURNO_SF2_FINAL))
		--END
		--SET @ENDT = @FECHA_FINAL

		 DECLARE @INIT_TIME AS DATETIME = (SELECT INITIAL_SHIFT_TIME FROM ADM.VW_C_SHIFT
												WHERE KY_SHIFT = @KYSHIFT)
           DECLARE @END_TIME AS DATETIME = (SELECT FINAL_SHIFT_TIME FROM ADM.VW_C_SHIFT
												WHERE KY_SHIFT = @KYSHIFT)
			SET @INIT = CONVERT(DATETIME, @ENDT) + CONVERT(DATETIME, @INIT_TIME)
			SET @ENDT = CONVERT(DATETIME, @ENDT) + CONVERT(DATETIME, @END_TIME)

		SET @COUNTER = (SELECT COUNT(*) FROM PRD.K_FOREMAN_AUTHORIZATION 
								WHERE DT_SYSTEM BETWEEN @INIT AND @ENDT)

		--SELECT @INIT INICIO, @ENDT FINAL, @COUNTER, @ENDT FECHA_QUE_METI
							
	 -- WE SEARCH BEST FOREMAN OF THE DAY(SHIFT).
	   IF (@COUNTER > 0) 
			BEGIN
				SELECT TOP 1
			 @NM_FOREMAN = KFA.KY_USER_FOREMAN, 
			 @COUNT_FOREMAN = COUNT(*) 
			FROM PRD.K_FOREMAN_AUTHORIZATION AS KFA
			INNER JOIN ADM.C_USER AS CU ON KFA.KY_USER_FOREMAN = CU.KY_USER
			INNER JOIN ADM.C_ROLE AS CR ON CR.ID_ROLE = CU.ID_ROLE
			WHERE KFA.DT_SYSTEM BETWEEN @INIT AND @ENDT
			AND KY_SHIFT = @KYSHIFT AND CR.NM_ROLE = 'Setup Tech'
			GROUP BY KFA.KY_USER_FOREMAN, CU.ID_EMPLOYEE ORDER BY KFA.KY_USER_FOREMAN DESC
		    END
	  ELSE  -- EN ESTE CASO TODO ESTÁ VACÍA LA TABLA DE FOREMAN_AUTH, POR LO TANTO, NO HAY REGISTROS EN ESE SHIFT.
			BEGIN
				SET @COUNTER = (SELECT COUNT(*) FROM PRD.K_SHIFT_FOREMAN 
									WHERE DT_SYSTEM BETWEEN @INIT AND @ENDT)
				IF (@COUNTER > 0)
					BEGIN
							SELECT TOP 1
							 @NM_FOREMAN = KSF.KY_USER, 
							 @COUNT_FOREMAN = COUNT(*) 
							FROM PRD.K_SHIFT_FOREMAN AS KSF
							INNER JOIN ADM.C_USER AS CU ON KSF.KY_USER = CU.KY_USER
							INNER JOIN ADM.C_ROLE AS CR ON CR.ID_ROLE = CU.ID_ROLE
							WHERE KSF.DT_SYSTEM BETWEEN @INIT AND @ENDT
							AND KSF.KY_SHIFT_TIME = @KYSHIFT AND CR.NM_ROLE = 'Setup Tech'
							GROUP BY KSF.KY_USER, CU.ID_EMPLOYEE ORDER BY KSF.KY_USER DESC
		    
					END
				ELSE
					BEGIN
					 SET @NM_FOREMAN = NULL
					END
			END

	--	SELECT @INIT FECHA_INICIAL, @ENDT FECHA_FINAL, DATEDIFF(HOUR,@INIT, @ENDT ) RANGO, @COUNTER COUNTER_FOREMAN, @NM_FOREMAN BEST_FOREMAN

		-- tabla temporal para extraer los tiempos donde cumplan el rango de fechas
		IF OBJECT_ID('tempdb..#RUNNING_HRS') IS NOT NULL
	   DROP TABLE #RUNNING_HRS
	CREATE TABLE #RUNNING_HRS(
	LEADMAN VARCHAR(200),
	TURNO VARCHAR(100),
	ID_QA27 INT,
	ID_WORK_ORDER INT,
	ID_PRODUCTION_LINE INT,
	DT_INITIAL_TIME DATETIME,
	DT_FINAL_TIME DATETIME,
	MIN_DURATION_HOURS INT,
	NM_MATERIAL VARCHAR(200),
	KY_ITEM VARCHAR(20),
	ID_ITEM INT,
	NM_CARTON VARCHAR(10),
	NO_SCRAP INT,
	FILM VARCHAR(10),
	NM_ITEM VARCHAR(200),
	NO_QTY_SKID FLOAT,
	NO_RUN_QTY INT,
	NO_POUNDS FLOAT,
	NO_WIDTH FLOAT,
	NO_BOX_QTY INT,
	NO_QTY_ADDED INT,
	FOREMAN VARCHAR(200),  
	ID_SHIFT INT,
	NM_LINE_PRODUCTION VARCHAR(200),
	LINE_OP VARCHAR(200))
	;WITH running_hrs
	as
 	(SELECT Q.NM_LEADMAN, Q.KY_SHIFT, Q.ID_QA27, W.ID_WORK_ORDER, PL.ID_PRODUCTION_LINE,  Q.DT_INITIAL_TIME, ISNULL(Q.DT_FINAL_TIME, GETDATE()) DT_FINAL_TIME, 
	--CASE WHEN (Q.DT_FINAL_TIME > @ENDT) THEN DATEDIFF(MINUTE, Q.DT_INITIAL_TIME, @ENDT) -- SI EL TIEMPO EN QUE FINALIZÓ FUE MUCHO DESPUÉS DEL TURNO ACTUAL
	--     WHEN (Q.DT_INITIAL_TIME < @INIT) THEN DATEDIFF(MINUTE, @INIT, Q.DT_FINAL_TIME) -- SI EL TIEMPO EN QUE INICIÓ FUE EN EL TURNO ANTERIOR
	--	 WHEN (Q.DT_INITIAL_TIME < @INIT) AND (Q.DT_FINAL_TIME > @ENDT) THEN DATEDIFF(MINUTE, @INIT,@ENDT) -- AQUI SERÍAN LAS 12 HORAS TRABAJADAS (INCIIO Y FINALIZÓ EN DÍAS DIFERENTES PERO ESTÁ DENTRO DEL RANGO DE FECHAS).
	-- ELSE
	-- DATEDIFF(MINUTE, Q.DT_INITIAL_TIME, Q.DT_FINAL_TIME) -- SINO ES NINGÚN CASO ANTERIOR, ENTONCES ESTÁ ENTRE EL RANGO DE FECHAS ESTABLECIDAS (DENTRO DEL TURNO).
	-- END AS MIN_DURATION
	 DATEDIFF(MINUTE, Q.DT_INITIAL_TIME, ISNULL(Q.DT_FINAL_TIME, GETDATE())) AS MIN_DURATION
	 , W.NM_MATERIAL, I.KY_ITEM, W.ID_ITEM,
	 CASE WHEN (SELECT TOP 1 NM_CARTON FROM PRD.K_WORK_ORDER_CARTON KWC WHERE KWC.ID_QA27 = Q.ID_QA27 ORDER BY KWC.DT_CREATION DESC) <> 'Null' THEN 'YES' ELSE 'NO' END NM_CARTON,

    (SELECT SUM (NO_SCRAP)
	 FROM PRD.K_WORK_ORDER_CARTON WO_CARTON 
	 WHERE WO_CARTON.ID_QA27 = Q.ID_QA27 GROUP BY ID_QA27) AS NO_SCRAP,


	 CASE WHEN (SELECT TOP 1 KFT.TOP_SIDE FROM PRD.K_FILM_TRACK KFT WHERE KFT.ID_QA27 = Q.ID_QA27 ORDER BY KFT.DT_CREATION DESC)  <> 'Null' THEN 'YES'
		  WHEN (SELECT TOP 1 KFT.BOTTOM_SIDE FROM PRD.K_FILM_TRACK KFT WHERE KFT.ID_QA27 = Q.ID_QA27 ORDER BY KFT.DT_CREATION DESC)  <> 'Null' THEN 'YES' 
		  ELSE 'NO' END AS FILM
	-- datediff convierte las fechas a minutos despues es dividido por 60 para convertir a horas
	,W.NM_ITEM, W.NO_QTY_SKID, W.NO_RUN_QTY, W.NO_POUNDS, W.NO_WIDTH, W.NO_BOX_QTY, NO_QTY_ADDED, Q.NM_FOREMAN, Q.ID_SHIFT, PL.NM_PRODUCTION_LINE,
	Q.LINE_OPERATOR FROM PRD.K_QA27 Q
	INNER JOIN PRD.K_WORK_ORDER W ON Q.ID_WORK_ORDER = W.ID_WORK_ORDER INNER JOIN PRD.C_ITEM I ON I.ID_ITEM= W.ID_ITEM
	INNER JOIN PRD.C_PRODUCTION_LINE PL ON W.ID_PRODUCTION_LINE = PL.ID_PRODUCTION_LINE  
	WHERE 
	DT_QA27 BETWEEN @INIT AND @ENDT AND Q.KY_SHIFT = @KYSHIFT AND W.ID_BRANCH_PLANT = @BP
	
	)
 INSERT INTO #RUNNING_HRS SELECT * FROM running_hrs

--SELECT * FROM #RUNNING_HRS RN ORDER BY RN.ID_WORK_ORDER --PRUEBA

 -- tabla temporal para extraer los eventos inproductivos "los time" de las wo
	 IF OBJECT_ID('tempdb..#EVENTS') IS NOT NULL
    DROP TABLE #EVENTS
CREATE TABLE #EVENTS(
QA27 INT,
ID_ISSUE INT,
ID_WORK_ORDER INT,
ID_PRODUCTION_LINE INT,
FG_LINE_DOWN BIT,
DT_ISSUE DATETIME,
DT_ISSUE_CLOSED DATETIME, 
MIN_DURATION INT)
;WITH events_unproductive
AS (SELECT KI.ID_QA27, KI.ID_ISSUE, KI.ID_WORK_ORDER, KI.ID_PRODUCTION_LINE,   KI.FG_LINE_DOWN, KI.DT_ISSUE, ISNULL(KI.DT_ISSUE_CLOSED, GETDATE()) DT_ISSUE_CLOSED, 
 CASE WHEN (DT_ISSUE > @INIT) AND (ISNULL(KI.DT_ISSUE_CLOSED, GETDATE()) < @ENDT) THEN DATEDIFF(MINUTE, KI.DT_ISSUE,ISNULL(KI.DT_ISSUE_CLOSED, GETDATE())) -- ENTRE EL TURNO, TODO BIEN.
	  WHEN (DT_ISSUE < @INIT) AND (ISNULL(KI.DT_ISSUE_CLOSED, GETDATE()) < @ENDT) THEN DATEDIFF(MINUTE, @INIT, ISNULL(KI.DT_ISSUE_CLOSED, GETDATE())) -- EMPIEZA EN EL TURNO ANTERIOR Y TERMINÓ EN PARTE DEL TURNO ACTUAL.
      WHEN (DT_ISSUE < @INIT) AND (ISNULL(KI.DT_ISSUE_CLOSED, GETDATE()) > @ENDT) THEN DATEDIFF(MINUTE, @INIT,  CASE WHEN DATEPART( SECOND,@ENDT) > 45 THEN    DATEADD(MINUTE, 1,@ENDT) ELSE @ENDT END) -- GRAVEDAD, PORQUE FUE DURANTE TODO EL TURNO ACTUAL.
 ELSE DATEDIFF(MINUTE, KI.DT_ISSUE,  CASE WHEN DATEPART( SECOND,@ENDT) > 45 THEN    DATEADD(MINUTE, 1,@ENDT) ELSE @ENDT END) -- DESDE TURNOS TODAVÍA MÁS ATRÁS HASTA EL CIERRE DEL TURNO ACTUAL.
 END AS MIN_DURATION 
   FROM PRD.K_ISSUE  KI 
   INNER JOIN PRD.K_WORK_ORDER KWO ON KI.ID_WORK_ORDER = KWO.ID_WORK_ORDER
 WHERE
 KWO.ID_BRANCH_PLANT =  @BP AND
    (DT_ISSUE  BETWEEN @INIT AND @ENDT)       -- dt issue init dentro de tiempo de dash
	OR (DT_ISSUE_CLOSED  BETWEEN @INIT AND @ENDT )-- dt issue end dentro de tiempo de dash
	 
    OR (@INIT BETWEEN DT_ISSUE AND CASE WHEN  KI.KY_STATUS='HOLD_ON' THEN GETDATE() ELSE DT_ISSUE_CLOSED END ) -- dt inicial de dash esta dentro de tiempo de 
	OR (@ENDT BETWEEN DT_ISSUE AND CASE WHEN  KI.KY_STATUS='HOLD_ON' THEN GETDATE() ELSE DT_ISSUE_CLOSED END) 
	
	OR ((@INIT BETWEEN DT_ISSUE AND CASE WHEN  KI.KY_STATUS='HOLD_ON' THEN GETDATE() ELSE DT_ISSUE_CLOSED END)
						AND (@ENDT BETWEEN DT_ISSUE AND CASE WHEN  KI.KY_STATUS='HOLD_ON' THEN GETDATE() ELSE DT_ISSUE_CLOSED END) )
						)
 -- KI.DT_ISSUE  BETWEEN @INIT AND @ENDT OR (@ENDT BETWEEN KI.DT_ISSUE AND KI.DT_ISSUE_CLOSED) AND KWO.ID_BRANCH_PLANT =  @BP)




 INSERT INTO #EVENTS SELECT * FROM events_unproductive

-- SOLAMENTE DEBEN CONTARSE PARA LA RESTA LOS EVENTOS QUE TIENEN LA BANDERA EN 1.

--print (@INIT)  print (@ENDT)


--  SELECT * FROM #EVENTS E -- select de prueba
 -- ORDER BY E.ID_PRODUCTION_LINE

-- TABLA TEMPORAL NUEVA PARA LOS TIEMPOS.
-- ¡ NUEVO !
	-- HAY QUE VERIFICAR SI EXISTEN MÁS DE UN EVENTO IMPRODUCTIVO PARA UNA WO, SINO PUES SE RESTA EL ÚNICO QUE HAY.
IF OBJECT_ID('tempdb..#RESIDUO_TIEMPO') IS NOT NULL
    DROP TABLE #RESIDUO_TIEMPO
	CREATE TABLE #RESIDUO_TIEMPO(
	WO INT,
	MINUS_MIN INT,
	FG_LINE_DOWN INT
	)
	 INSERT INTO #RESIDUO_TIEMPO(WO,MINUS_MIN, FG_LINE_DOWN) 
	 SELECT E.ID_WORK_ORDER, SUM(E.MIN_DURATION) MIN_BY_SAME_WO, E.FG_LINE_DOWN
						FROM #EVENTS E WHERE E.FG_LINE_DOWN = 1
						GROUP BY E.ID_WORK_ORDER, FG_LINE_DOWN
						ORDER BY E.ID_WORK_ORDER

 --  SELECT * FROM #RESIDUO_TIEMPO -- SELECT DE PRUEBA 

-- tabla temporal para restar los eventos inproductivos a la tabla running_hrs
 	 IF OBJECT_ID('tempdb..#RESTA_TIEMPO_INPRODUCTIVO') IS NOT NULL
    DROP TABLE #RESTA_TIEMPO_INPRODUCTIVO
	CREATE TABLE #RESTA_TIEMPO_INPRODUCTIVO(
	PRODUCTION_LINE INT,
	MIN_REAL_HRS INT,
	WO INT)

	-- ANALISIS DE DIVIDE BY ZERO
	-- Aquí se resta el tiempo de duración que estuvo en la línea de producción con el evento improductivo 
	-- y el resultado sigue siendo en minutos, ya que la base de datos no es precisa en cuanto a LA HORA (se redondea).

    INSERT INTO #RESTA_TIEMPO_INPRODUCTIVO(PRODUCTION_LINE, MIN_REAL_HRS, WO)
	SELECT DISTINCT RN.ID_PRODUCTION_LINE,(RN.MIN_DURATION_HOURS - RT.MINUS_MIN) RESTA_CHIDA, RN.ID_WORK_ORDER 
	FROM #RUNNING_HRS RN
	INNER JOIN #EVENTS E ON RN.ID_WORK_ORDER = E.ID_WORK_ORDER  
	INNER JOIN #RESIDUO_TIEMPO RT ON E.ID_WORK_ORDER = RT.WO
	WHERE 
	--E.DT_ISSUE BETWEEN @INIT AND @ENDT AND 
	E.FG_LINE_DOWN  = 1 
	GROUP BY E.ID_WORK_ORDER,RN.ID_WORK_ORDER,E.ID_PRODUCTION_LINE,  
		     RN.ID_PRODUCTION_LINE,E.MIN_DURATION, RN.MIN_DURATION_HOURS, RT.MINUS_MIN
	
	-- SELECT * FROM #RESTA_TIEMPO_INPRODUCTIVO RTI --SELECT DE PRUEBA DE EVENTOS IMPRODUCTIVOS.
	-- ORDER BY RTI.WO
	
 --ACTUALIZA LAS HORAS DE LA TABLA RUNNING HOURS
 UPDATE #RUNNING_HRS
     SET MIN_DURATION_HOURS = RTI.MIN_REAL_HRS
     FROM #RESTA_TIEMPO_INPRODUCTIVO RTI
   WHERE ID_WORK_ORDER = RTI.WO  

  -- SELECT * FROM #RUNNING_HRS RN -- select de prueba donde se actualiza la tabla running hours
  -- ORDER BY RN.ID_PRODUCTION_LINE, RN.ID_WORK_ORDER
  

   
  -- tabla temporal para la extracion de el line rate

  IF OBJECT_ID('tempdb..#LINE_RATE') IS NOT NULL
    DROP TABLE #LINE_RATE
CREATE TABLE #LINE_RATE(
	ID_WO INT,
	DT_CLOSED DATETIME,
	ID_PRODUCTION_LINE INT,
	QA27 INT,
	LINE_RATE VARCHAR(10),
	LEADMAN VARCHAR(200),
	ID_ITEM INT)
-- LINE RATE 
;WITH line_rate
AS (SELECT DISTINCT RN.ID_WORK_ORDER,  RN.DT_FINAL_TIME  DT_CLOSED ,  RN.ID_PRODUCTION_LINE, RN.ID_QA27,
	 NULL AS LINE_RATE,
	 RN.LEADMAN, 
	 RN.ID_ITEM
FROM  #RUNNING_HRS RN )

    
	  INSERT INTO #LINE_RATE SELECT  * FROM  line_rate
	
	
UPDATE TLR
	--SET  TLR.LINE_RATE = (SELECT TOP 1 XML_METRICS_VALUE.value('(/FIELD_TYPES/@FINISHED_VALUE)[1]', 'varchar(20)') FROM PRD.K_FORM_METRICS KFM INNER JOIN PRD.K_FORM KF ON KF.ID_K_FORM = KFM.ID_K_FORM AND KFM.ID_METRICS = 66 AND KF.KY_STATUS_FORM = 'CAPTURED' AND KF.KY_PROCESS_TYPE = 'PROCESS' AND KF.ID_PRODUCTION_LINE = TLR2 .ID_PRODUCTION_LINE INNER JOIN PRD.K_WORK_ORDER WO ON WO.ID_WORK_ORDER=KF.ID_WORK_ORDER WHERE WO.ID_ITEM=TLR2 .ID_ITEM AND KF.DT_CREATION <= TLR.DT_CLOSED  ORDER BY KF.DT_CREATION DESC)
SET  TLR.LINE_RATE = (SELECT TOP 1 XML_METRICS_VALUE.value('(/FIELD_TYPES/@FINISHED_VALUE)[1]', 'varchar(20)') FROM PRD.K_FORM_METRICS KFM INNER JOIN PRD.K_FORM KF ON KF.ID_K_FORM = KFM.ID_K_FORM AND KFM.ID_METRICS = 66 AND KF.KY_STATUS_FORM = 'CAPTURED' AND KF.KY_PROCESS_TYPE = 'PROCESS' AND KF.ID_PRODUCTION_LINE = TLR2 .ID_PRODUCTION_LINE INNER JOIN PRD.K_WORK_ORDER WO ON WO.ID_WORK_ORDER=KF.ID_WORK_ORDER WHERE KF.DT_CREATION <= TLR.DT_CLOSED AND  XML_METRICS_VALUE.value('(/FIELD_TYPES/@FINISHED_VALUE)[1]', 'varchar(20)') IS NOT NULL   ORDER BY KF.DT_CREATION DESC)
	FROM #LINE_RATE TLR INNER JOIN #LINE_RATE TLR2 ON TLR2.QA27 = TLR.QA27 


	   --SELECT * FROM #LINE_RATE

-- tabla temporal para extraer el peso de la hoja
IF OBJECT_ID('tempdb..#WEIGHT') IS NOT NULL
    DROP TABLE #WEIGHT
CREATE TABLE #WEIGHT(
ID_WO INT,
QA27 INT,
WEIGHT_VALUE DECIMAL(13,4),
LEADMAN VARCHAR(200))
;WITH weight_value
AS (SELECT ID_WORK_ORDER ID_WO, ID_QA27  QA27, NULL WEIGHT_VALUE, NULL LEADMAN FROM #RUNNING_HRS )

INSERT INTO #WEIGHT SELECT  * FROM  weight_value


UPDATE TW SET TW.WEIGHT_VALUE = WEI.KF_WEIGHT 
FROM #WEIGHT TW  INNER JOIN 



	(	SELECT KF.ID_WORK_ORDER, AVG(KFM.XML_METRICS_VALUE.value('(/FIELD_TYPES/@FINISHED_VALUE)[1]', 'DECIMAL(13,7)'))  KF_WEIGHT 
	FROM #RUNNING_HRS RN INNER JOIN PRD.K_FORM KF ON KF.ID_WORK_ORDER = RN.ID_WORK_ORDER
	INNER JOIN PRD.K_QA27 Q ON Q.ID_QA27=KF.ID_QA27
	INNER JOIN PRD.K_PALLET KP ON KP.ID_PALLET = KF.ID_PALLET 
	--AND Q.ID_QA27=KP.ID_QA27 
	INNER JOIN ADM.VW_C_PALLET_STATUS VCPS
			ON KP.KY_STATUS = VCPS.KY_PALLET_STATUS
			AND VCPS.FG_FOR_SAVE = 1
		INNER JOIN PRD.K_FORM_METRICS KFM
			ON KF.ID_K_FORM = KFM.ID_K_FORM
			AND KFM.ID_METRICS =  36
	WHERE KF.KY_PROCESS_TYPE = 'MANUFACTURE'
		AND KF.KY_STATUS_FORM = 'CAPTURED'
		AND Q.ID_QA27 = RN.ID_QA27  GROUP BY KF.ID_WORK_ORDER)
		 WEI  ON  TW.ID_WO= WEI.ID_WORK_ORDER


--(SELECT KF.ID_WORK_ORDER, AVG(KFM.XML_METRICS_VALUE.value('(/FIELD_TYPES/@FINISHED_VALUE)[1]', 'DECIMAL(13,7)')) KF_WEIGHT FROM 
--#RUNNING_HRS RN INNER JOIN PRD.K_FORM KF ON KF.ID_WORK_ORDER = RN.ID_WORK_ORDER
--INNER JOIN PRD.K_FORM_METRICS KFM
--			ON KF.ID_K_FORM = KFM.ID_K_FORM
--			AND KF.KY_PROCESS_TYPE IN ('MANUFACTURE')
--			AND KF.KY_STATUS_FORM = 'CAPTURED'
--			AND KFM.ID_METRICS=36
--			AND KF.ID_WORK_ORDER = RN.ID_WORK_ORDER
--			WHERE 
--			 KFM.XML_METRICS_VALUE.value('(/FIELD_TYPES/@FINISHED_VALUE)[1]', 'VARCHAR(20)') <> 'null' AND
--			(KFM.DT_CREATION  BETWEEN CONVERT(DATE, @INIT) AND CONVERT(DATE, @ENDT) OR 
--	  CONVERT(DATE, @INIT) BETWEEN CONVERT(DATE, KFM.DT_CREATION) AND KF.DT_CLOSED)
--	  OR CONVERT(DATE, @ENDT) BETWEEN CONVERT(DATE, KFM.DT_CREATION) AND KF.DT_CLOSED
--	  GROUP BY KF.ID_WORK_ORDER) 
	  


UPDATE T1 SET T1.WEIGHT_VALUE = ROUND( W.NO_POUNDS,4,4) FROM #WEIGHT T1 INNER JOIN PRD.K_QA27 Q ON Q.ID_QA27= T1.QA27 
INNER JOIN PRD.K_WORK_ORDER W ON W.ID_WORK_ORDER = Q.ID_WORK_ORDER WHERE T1.WEIGHT_VALUE IS NULL

---SELECT * FROM #WEIGHT ORDER BY ID_WO,QA27 -- select de prueba

	-- tabla temporal para contar el numero de skids cuando cumplen el rango de fechas
		IF OBJECT_ID('tempdb..#NUM_SKIDS') IS NOT NULL
		DROP TABLE #NUM_SKIDS
	CREATE TABLE #NUM_SKIDS(
	WO INT,
	QA27 INT,
	PALLETS  INT,
	QUANTITY INT,
	DT_INI DATETIME,
	DT_FIN_OP DATETIME,
	STATUSS VARCHAR(200),
	PRODUCTION_LINE INT)

		;WITH num_skids AS
	(SELECT 
	RN.ID_WORK_ORDER, P.ID_QA27, P.NO_PALLET, P.NO_QUANTITY,
	 P.DT_INITIAL_TIME, P.DT_FINAL_OPERATION_TIME, P.KY_STATUS, RN.ID_PRODUCTION_LINE FROM 
	 PRD.K_PALLET P 
	INNER JOIN #RUNNING_HRS RN ON P.ID_QA27 = RN.ID_QA27 AND  P.KY_STATUS IN ('ACCEPTED', 'SAVE_AS_IS', 'NON_INSPECTED', 'CUSTOMER_WAIVER')
	 WHERE P.DT_INITIAL_TIME BETWEEN @INIT AND @ENDT OR P.DT_FINAL_OPERATION_TIME BETWEEN @INIT AND @ENDT )
	 INSERT INTO #NUM_SKIDS SELECT * FROM num_skids 
	 --DELETE FROM #NUM_SKIDS WHERE STATUSS = 'GRIND'
	 --DELETE FROM #NUM_SKIDS WHERE STATUSS =  'SKIPPED'
	 --DELETE FROM #NUM_SKIDS WHERE STATUSS = 'NON_CONFORMANCE'
	 --DELETE FROM #NUM_SKIDS WHERE STATUSS =  'BACK_TO_REVIEW'
	 ----DELETE FROM #NUM_SKIDS WHERE STATUSS =  'WORKING'
 
   -- SELECT * FROM #NUM_SKIDS NS  -- select de prueba

-- tabla temporal para contar el numero de skids por qa27
	 IF OBJECT_ID('tempdb..#COUNT_QA27_NUM_SKIDS') IS NOT NULL
		DROP TABLE #COUNT_QA27_NUM_SKIDS
	CREATE TABLE #COUNT_QA27_NUM_SKIDS(
	QA27 INT,
	PRODUCTION_LINE INT,
	SKIDS_COUNT INT,
	WO INT)
	;WITH  count_qa27_num_skids
	AS (SELECT NS.QA27, NS.PRODUCTION_LINE, COUNT(NS.QA27) AS SKIDS_COUNT,
	 NS.WO
	FROM #NUM_SKIDS NS
	INNER JOIN #RUNNING_HRS RN ON NS.QA27 = RN.ID_QA27
	GROUP BY NS.QA27, NS.PRODUCTION_LINE, RN.ID_WORK_ORDER, NS.WO)

	INSERT INTO #COUNT_QA27_NUM_SKIDS SELECT * FROM count_qa27_num_skids

-- select * from #COUNT_QA27_NUM_SKIDS AS QNM ORDER BY QNM.PRODUCTION_LINE --- select de prueba

-- tabla temporal para calcular las libras extruidas de la wo
	IF OBJECT_ID('tempdb..#EXTRAR_PRODUCED_AND_EXTRUDED') IS NOT NULL
		DROP TABLE #EXTRAR_PRODUCED_AND_EXTRUDED
	CREATE TABLE #EXTRAR_PRODUCED_AND_EXTRUDED(
	WO INT,
	QA27 INT,
	PRODUCTION_LINE INT,
	PRODUCED DECIMAL(10,2),
	GROSS DECIMAL(10,2))
	;WITH  shift_saving
	AS (SELECT DISTINCT
	-- Para calcular lo producido son los boxes que se hacen en esa wo, cuántas skids hubo y el peso.
	RN.ID_WORK_ORDER, RN.ID_QA27, RN.ID_PRODUCTION_LINE, 
	(ISNULL(RN.NO_BOX_QTY,0) * ISNULL(CQS.SKIDS_COUNT,0) * ISNULL(WEI.WEIGHT_VALUE,0)) AS PRODUCED_LBS,
	CASE WHEN RN.MIN_DURATION_HOURS > 0 THEN
	(LR.LINE_RATE * (CONVERT(DECIMAL(10,5),RN.MIN_DURATION_HOURS) / CONVERT(DECIMAL(10,5),60))) ELSE 0 END AS EXTRUDED_LBS -- GROSS
	FROM #RUNNING_HRS RN
	LEFT JOIN #LINE_RATE LR ON LR.QA27 = RN.ID_QA27
	LEFT JOIN #WEIGHT WEI ON WEI.QA27 = RN.ID_QA27
	LEFT JOIN #COUNT_QA27_NUM_SKIDS CQS ON RN.ID_WORK_ORDER = CQS.WO)  

	INSERT INTO #EXTRAR_PRODUCED_AND_EXTRUDED SELECT * FROM shift_saving

  
    --- select * from #EXTRAR_PRODUCED_AND_EXTRUDED  AS EP ORDER BY EP.PRODUCTION_LINE, EP.WO -- select de prueba


	--SUMATORIA DE GROSS, PRODUCED AND SAVING RATE
	SELECT  @VALUE_PRODUCED_TOTAL = SUM(EPAE.PRODUCED) FROM #EXTRAR_PRODUCED_AND_EXTRUDED EPAE
	SELECT @VALUE_GROSS_LINE = SUM(EPAE.GROSS) FROM #EXTRAR_PRODUCED_AND_EXTRUDED EPAE
	-- AQUI VA LA VALIDACION DE DIVIDE BY ZERO
	 SELECT @TOTAL_SHIFT_SAVING = (@VALUE_PRODUCED_TOTAL / NULLIF(@VALUE_GROSS_LINE,0) * 100)

  -- SELECT @TOTAL_SHIFT_SAVING SHIFT_SAVING, @VALUE_GROSS_LINE   GROSS_LINE -- select de prueba

	IF OBJECT_ID('tempdb..#NON_PRODUCTION_REASON') IS NOT NULL
		DROP TABLE #NON_PRODUCTION_REASON
	CREATE TABLE #NON_PRODUCTION_REASON(
	QA27 INT,
	DESCRIPTIONS VARCHAR(600))
	;WITH non_production_reason
	 --consulta para traer los comentarios de los eventos inproductivos
	AS (SELECT DISTINCT KI.ID_QA27, KI.DS_EXPLANATION_EVENT_CLOSED FROM PRD.K_ISSUE KI
	INNER JOIN #RUNNING_HRS RN ON KI.ID_QA27 = RN.ID_QA27
	WHERE KI.FG_LINE_DOWN = 0 AND KI.KY_STATUS = 'CLOSED')
	INSERT INTO #NON_PRODUCTION_REASON  SELECT * FROM non_production_reason

 -- select * from #NON_PRODUCTION_REASON -- select de prueba

		-- consulta final uniendo las tablas creadas
		SELECT DISTINCT
		@FECHA_GENERACION_REPORTE AS DATE_,
		SUBSTRING(KS.KY_SHIFT_TIME , 4,1) AS [SHIFT],-- se crea un substring para unicamente extraer a,b,c,d
		CONVERT(DECIMAL(10,4),@TOTAL_SHIFT_SAVING) AS SHIFT_SAVING,
		CONVERT(DECIMAL(10,4),@VALUE_PRODUCED_TOTAL) AS PRODUCED,
		CONVERT(DECIMAL(10,4),@VALUE_GROSS_LINE) AS GROSS,
		RN.LEADMAN AS LEADMAN,-- LEADMAN
		(CASE WHEN RN.FOREMAN IS NULL THEN @NM_FOREMAN
		      WHEN @NM_FOREMAN IS NULL  THEN '' END) AS FOREMAN,
		RN.LINE_OP,-- CUT-OFF ESTE APARTADO CAMBIARÁ DESDE EL MOTOR V2
		RN.NM_MATERIAL AS MATERIAL,-- MATERIAL
		RN.ID_WORK_ORDER AS ID_WORK_ORDER,
		RN.ID_QA27,
		RN.ID_PRODUCTION_LINE AS PRODUCTION_LINE,-- WO
		RN.NM_LINE_PRODUCTION AS NAME_PRODUCTION_LINE,
		RN.NM_CARTON AS CARTON,
		RN.NO_SCRAP AS SCRAP,
		RN.FILM,
		RN.KY_ITEM, 
		RN.NM_ITEM AS ITEM,-- ITEM
		LR.LINE_RATE AS LINE_RATE,-- RATE
		RN.NO_BOX_QTY AS PCS_SKIDS,-- PCS/SKID
		ISNULL((SELECT TOP 1 NO_PALLET  FROM PRD.K_PALLET KP WHERE KP.ID_WORK_ORDER = RN.ID_WORK_ORDER ORDER BY ID_PALLET DESC),0) AS NUM_SKIDS,-- #SKIDS
		CEILING((RN.NO_RUN_QTY + RN.NO_QTY_ADDED) / NO_QTY_SKID) AS TOTAL_SKIDS, 
		WEI.WEIGHT_VALUE AS SHEET_WEIGHT,-- WEIGHT
		CONVERT(DECIMAL(10,2),(CONVERT(DECIMAL(10,5),RN.NO_BOX_QTY) * 
		CONVERT(DECIMAL(10,5),ISNULL(CQS.SKIDS_COUNT,0)) * CONVERT(DECIMAL(10,5),WEI.WEIGHT_VALUE))) AS PRODUCED_LBS,-- PRODUCED LBS
		CASE WHEN RN.MIN_DURATION_HOURS > 0 THEN 
		(CONVERT(DECIMAL(10,2),CONVERT(DECIMAL(10,5),LR.LINE_RATE)) * (CONVERT(DECIMAL(10,2), CONVERT(DECIMAL(10,5),
								CONVERT(DECIMAL(10,5),RN.MIN_DURATION_HOURS))/CONVERT(DECIMAL(10,5),60)))) ELSE 0 END AS EXTRUDED_LBS,-- EXTRUDED LBS

		CASE WHEN RN.MIN_DURATION_HOURS > 0 THEN CONVERT(DECIMAL(10,4),(CONVERT(DECIMAL(10,5),RN.MIN_DURATION_HOURS) / CONVERT(DECIMAL(10,5),60)))
		ELSE 0 END  AS RUNNING_HRS,

		CASE WHEN RN.MIN_DURATION_HOURS > 0  THEN 
		CONVERT(DECIMAL(10,4),((CONVERT(DECIMAL(10,5),RN.NO_BOX_QTY) * CONVERT(DECIMAL(10,5),ISNULL(CQS.SKIDS_COUNT,0)) * 
								CONVERT(DECIMAL(10,4),CONVERT(DECIMAL(10,5),WEI.WEIGHT_VALUE)))/(CONVERT(DECIMAL(10,5),LR.LINE_RATE) * 
						(CONVERT(DECIMAL(10,4), CONVERT(DECIMAL(10,5),RN.MIN_DURATION_HOURS)/CONVERT(DECIMAL(10,5),60)))) 
						 * CONVERT(DECIMAL(10,2),100))) ELSE 0 END AS SAVING_RATE,-- SAVING RATE
		NPL.DESCRIPTIONS AS NON_PRODUCTION_REASON-- NON-PRODUCED REGLA se encuentra en la consulta de la parte superior
		, COALESCE((SELECT COUNT(*) FROM PRD.K_INSPECTION_SKID KIS
		INNER JOIN PRD.K_PALLET KP ON KP.ID_WORK_ORDER = KIS.ID_WORK_ORDER AND KP.NO_PALLET = KIS.NO_PALLET
		WHERE KIS.ID_WORK_ORDER = RN.ID_WORK_ORDER 
		AND KP.KY_STATUS IN (SELECT KY_PALLET_STATUS FROM ADM.VW_C_PALLET_STATUS  VWPS WHERE VWPS.KY_TEMP_STATUS = 'H')),0) AS SKIDS_ON_HOLD
		FROM #RUNNING_HRS RN
		LEFT JOIN #LINE_RATE LR ON LR.QA27 = RN.ID_QA27
		LEFT JOIN #WEIGHT WEI ON WEI.QA27 = RN.ID_QA27
		LEFT JOIN #COUNT_QA27_NUM_SKIDS CQS ON CQS.WO = RN.ID_WORK_ORDER 
		INNER JOIN PRD.K_SHIFT KS ON RN.ID_SHIFT = KS.ID_SHIFT
		LEFT JOIN #NON_PRODUCTION_REASON NPL ON RN.ID_QA27 = NPL.QA27
		ORDER BY RN.ID_PRODUCTION_LINE
		END



