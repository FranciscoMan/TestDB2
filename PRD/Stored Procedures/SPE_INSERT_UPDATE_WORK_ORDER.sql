
-- =============================================
-- Proyecto: Plaskolite
-- Copyright (c) - Acrux - 2017
-- Author: Juan De Dios Pérez
-- CRETAE date: 04/04/2017
-- Description: Insert or update a Work Order
-- =============================================
-- 2017 12 19 JDR @PIN_XML_TRANSITIONS parameter added
-- 2018 05 12 JDR Puts a default value if it's null on NO_LENGHT, NO_WIDTH and NO_THICKNESS
-- 2018 06 15 JDR When you insert the imported work orders, the sequence of the work orders scheduled and those skipped with the information from JDEdwards is updated.
-- =============================================

CREATE PROCEDURE  [PRD].[SPE_INSERT_UPDATE_WORK_ORDER] 
	@XML_RESULT XML = '' OUT    -- --0 TO ERROR AND 1 TO CORRECT
	, @PIN_XML_WORK_ORDERS AS XML = NULL
	, @PIN_XML_TRANSITIONS AS XML = NULL
	, @PIN_KY_USER AS nvarchar(50)
	, @PIN_NM_PROGRAM AS nvarchar(50)
	, @PIN_TYPE_TRANSACTION CHAR(1) ='I'--I=INSERT   U=UPDATE

AS 
BEGIN  
	----WE DECLARE THE STARTED VARIABLE THAT INDICATES IF WE WILL HAVE A TRANSACTION ON SPE
	DECLARE @V_EXIST_TRAN BIT = 0
		,@DT_SYSTEM DATETIME = GETDATE()
		,@KY_WORK_ORDER_SCHEDULED_STATUS NVARCHAR(20) = 'SCHEDULED'

	CREATE TABLE #T_WORKORDER  (
		ID_WORK_ORDER INT
		, KY_CUSTOMER NVARCHAR(50)
		, NM_CUSTOMER NVARCHAR(200)
		, NO_WORK_ORDER INT
		, NO_PRODUCTION_TIME INT
		, NO_TRANSITIONS_TIME INT
		, KY_TRANSITION NVARCHAR(50)
		, NM_TRANSITION NVARCHAR(100)
		, NO_STANDARD_TIME INT
		, ID_ITEM INT
		, NM_ITEM NVARCHAR(100)
		, ID_BRANCH_PLANT INT
		, ID_PRODUCTION_LINE INT
		, NM_PRODUCTION_LINE NVARCHAR(300)
		, DT_WORK_ORDER DATETIME
		, DT_START_WORK_ORDER DATETIME
		, NO_RUN_QTY INT
		, NO_BOX_QTY INT
		, NM_MATERIAL NVARCHAR(200)
		, NM_COLOR NVARCHAR(100)
		, NO_LENGHT FLOAT
		, NO_WIDTH FLOAT
		, NO_THICKNESS FLOAT
		, NO_POUNDS	FLOAT
		, KY_PACKAGE NVARCHAR(50)
		, PACKED INT
		, DT_REQ_DATE DATETIME
		, NO_ORDER INT
		, NO_SEQ INT
		, NO_HRS_LABOR_MACHINE INT
		, NO_QTY_SKID FLOAT
		, DT_ORDER DATETIME
		, NO_SHIPING_WEIGHT_PER_HR FLOAT
		, KY_UPC NVARCHAR(20)
		, KY_STATUS NVARCHAR(50)
		, ID_WORK_ORDER_ORIGIN INT
		, ID_PALLET INT
		, DT_CLOSE_WORK_ORDER DATETIME
		, DT_CREATION DATETIME
		, KY_USER_APP_CREATION NVARCHAR(50)	
		, NM_PROGAM_CREATE NVARCHAR(50)
	)

	CREATE TABLE #T_WORKORDER_ALT  (
		ID_WORK_ORDER INT
		, NO_WORK_ORDER INT
		, NO_QTY_SKID INT
	)

	CREATE TABLE #T_TRANSITION  (
		ID_WORK_ORDER INT
		, ID_TRANSITION INT
	)

	CREATE TABLE #T_PRODUCTION_LINE  (
		ID_PRODUCTION_LINE INT
		, DT_LAST_WORK_ORDER DATETIME
	)

    BEGIN TRY
		--WE VERIFY THAT EXISTS A WORKING TRANSACTION
		IF (@@TRANCOUNT = 0) BEGIN
			--IN CASE THAT THE TRANSACTION DOESNT START
			BEGIN TRANSACTION
			--IT EDITS THE VARIABLE THAT INDICATES THAT THE TRANSACTION START IN THIS BLOCK TO CANCEL IN ANY MOMENT
			SET @V_EXIST_TRAN = 1
		END	

		--WE VERIFY IF THE SPE IS GOING TO EXECUTE A UPDATE OR INSERT
		IF @PIN_TYPE_TRANSACTION = 'I' BEGIN
			--WE INSERT THE REGISTER ON THE TABLE  PRD.K_WORK_ORDERS


			-- INSERT XML WORK ORDERS DATA ON THE ALTERNATIVE WORK ORDER TABLE VARIABLE

			INSERT INTO #T_WORKORDER_ALT (ID_WORK_ORDER, NO_WORK_ORDER, NO_QTY_SKID)
			SELECT d.value('@ID_WORK_ORDER', 'INT') AS ID_WORK_ORDER
				, d.value('@NO_WORK_ORDER', 'INT') AS NO_WORK_ORDER
				, d.value('@NO_QTY_SKID', 'INT') AS NO_QTY_SKID
			FROM @PIN_XML_WORK_ORDERS.nodes('WORKORDERS/WORKORDER') AS T(d)

			-- INSERT XML TRANSITIONS DATA ON THE TRANSITIONS TABLE VARIABLE

			INSERT INTO #T_TRANSITION (ID_WORK_ORDER, ID_TRANSITION)
			SELECT d.value('@ID_WORK_ORDER', 'INT') AS ID_WORK_ORDER
				, d.value('@ID_TRANSITION', 'INT') AS ID_TRANSITION
			FROM @PIN_XML_TRANSITIONS.nodes('TRANSITIONS/TRANSITION') AS T(d)


			-- INSERT THE WORK ORDER DATA

			INSERT INTO #T_WORKORDER (ID_WORK_ORDER
				, KY_CUSTOMER
				, NM_CUSTOMER
				, NO_WORK_ORDER
				, NO_PRODUCTION_TIME
				, NO_TRANSITIONS_TIME
				, ID_ITEM
				, NM_ITEM
				, ID_BRANCH_PLANT
				, ID_PRODUCTION_LINE
				, NM_PRODUCTION_LINE
				, NO_RUN_QTY
				, NO_BOX_QTY
				, NM_MATERIAL
				, NM_COLOR
				, NO_LENGHT
				, NO_WIDTH
				, NO_THICKNESS
				, NO_POUNDS
				, KY_PACKAGE
				, PACKED
				, DT_REQ_DATE
				, NO_ORDER
				, NO_SEQ
				, NO_QTY_SKID
				, DT_ORDER
				, NO_SHIPING_WEIGHT_PER_HR
				, KY_UPC
				, KY_STATUS
				, ID_WORK_ORDER_ORIGIN
				, ID_PALLET
				, DT_CLOSE_WORK_ORDER
				, DT_CREATION
				, KY_USER_APP_CREATION
				, NM_PROGAM_CREATE
			)
			SELECT VKWOJ.ID_WORK_ORDER
				, VKWOJ.KY_CUSTOMER
				, VKWOJ.NM_CUSTOMER
				, VKWOJ.NO_WORK_ORDER
				, CAST(ROUND((((CI.NO_POUNDS_PER_ITEM * VKWOJ.NO_RUN_QTY ) / CPL.NO_POUNDS_PER_HOUR) * 60), 0) AS INT)
				, 0 -- NO_TRANSITIONS_TIME
				, CI.ID_ITEM
				, CI.NM_ITEM
				, CPL.ID_BRANCH_PLANT
				, CPL.ID_PRODUCTION_LINE
				, CPL.NM_PRODUCTION_LINE
				, VKWOJ.NO_RUN_QTY
				, TW.NO_QTY_SKID
				, VKWOJ.NM_MATERIAL
				, VKWOJ.NM_COLOR
				, VKWOJ.NO_LENGHT
				, VKWOJ.NO_WIDTH
				, VKWOJ.NO_THICKNESS
				, CI.NO_POUNDS_PER_ITEM
				, VKWOJ.KY_PACKAGE
				, VKWOJ.PACKED
				, VKWOJ.DT_REQ_DATE
				, VKWOJ.NO_ORDER
				, VKWOJ.NO_SEQ
				, TW.NO_QTY_SKID
				, VKWOJ.DT_REQ_DATE
				, VKWOJ.NO_SHIPING_WEIGHT_PER_HR
				, CI.KY_UPC
				, @KY_WORK_ORDER_SCHEDULED_STATUS
				, NULL -- ID_WORK_ORDER_ORIGIN
				, NULL -- ID_PALLET
				, NULL -- DT_CLOSE_WORK_ORDER
				, @DT_SYSTEM
				, @PIN_KY_USER
				, @PIN_NM_PROGRAM
			FROM PRD.VW_K_WORK_ORDER_JDEDWARDS VKWOJ
				INNER JOIN #T_WORKORDER_ALT TW
					ON TW.ID_WORK_ORDER = VKWOJ.ID_WORK_ORDER
				INNER JOIN PRD.C_ITEM CI
					ON VKWOJ.ID_ITEM = CI.ID_ITEM
				INNER JOIN PRD.C_PRODUCTION_LINE CPL
					ON VKWOJ.ID_PRODUCTION_LINE = CPL.ID_PRODUCTION_LINE
			WHERE EXISTS (SELECT TOP 1 1 FROM #T_WORKORDER_ALT TWA WHERE TWA.ID_WORK_ORDER = VKWOJ.ID_WORK_ORDER)

			;WITH T_WORK_ORDER AS ( -- GET WORK ORDERS DATETIME FROM EACH PRODUCTION LINE
				SELECT KWO.ID_PRODUCTION_LINE
					, DATEADD(MINUTE, KWO.NO_ASSIGNED_TIME, KWO.DT_WORK_ORDER) AS DT_LAST_SCHEDULED_WO_TIME
					, ROW_NUMBER() OVER (PARTITION BY KWO.ID_PRODUCTION_LINE ORDER BY KWO.ID_PRODUCTION_LINE, KWO.DT_WORK_ORDER DESC) AS NO_LINE
				FROM PRD.K_WORK_ORDER KWO
				WHERE EXISTS (SELECT TOP 1 1 FROM #T_WORKORDER TWO WHERE KWO.ID_PRODUCTION_LINE = TWO.ID_PRODUCTION_LINE)
					AND DATEADD(MINUTE, KWO.NO_ASSIGNED_TIME, KWO.DT_WORK_ORDER) > @DT_SYSTEM
			), T_LAST_WORK_ORDER AS ( -- GET LAST WORK ORDER DATETIME FROM EACH PRODUCTION LINE
				SELECT ID_PRODUCTION_LINE, DT_LAST_SCHEDULED_WO_TIME
				FROM T_WORK_ORDER
				WHERE NO_LINE = 1
			)

			-- GET AVAILABLE TIME TO SCHEDULE FOR EACH PRODUCTION LINE
			--SELECT TWO.ID_PRODUCTION_LINE, ISNULL(TLWO.DT_LAST_SCHEDULED_WO_TIME, @DT_SYSTEM)
			UPDATE TWO
				SET DT_WORK_ORDER = ISNULL(TLWO.DT_LAST_SCHEDULED_WO_TIME, @DT_SYSTEM)
			FROM #T_WORKORDER TWO
				LEFT JOIN T_LAST_WORK_ORDER TLWO
					ON TWO.ID_PRODUCTION_LINE = TLWO.ID_PRODUCTION_LINE
			
			-- GET THE TOTAL TRANSITIONS TIME

			; WITH T_GROUPED_TRANSITIONS AS (
				SELECT ID_WORK_ORDER, SUM(CT.NO_STANDARD_TIME) AS NO_TRANSITIONS_TIME
				FROM #T_TRANSITION TT
					INNER JOIN PRD.C_TRANSITION CT
						ON TT.ID_TRANSITION = CT.ID_TRANSITION
				GROUP BY ID_WORK_ORDER
			)
			UPDATE TWO
				SET NO_TRANSITIONS_TIME = TGT.NO_TRANSITIONS_TIME
			FROM #T_WORKORDER TWO
				INNER JOIN T_GROUPED_TRANSITIONS TGT
					ON TWO.ID_WORK_ORDER = TGT.ID_WORK_ORDER

			; WITH T_WORK_ORDER AS (
				SELECT ROW_NUMBER() OVER (PARTITION BY TWO.ID_PRODUCTION_LINE ORDER BY TWO.ID_PRODUCTION_LINE, TWO.NO_SEQ) NO_LINE
					, ID_WORK_ORDER
					, NO_PRODUCTION_TIME + NO_TRANSITIONS_TIME AS NO_ASSIGNED_TIME
					, ID_PRODUCTION_LINE
				FROM #T_WORKORDER TWO
			), T_PREVIOUS_ASSIGNED_TIME AS (
				SELECT TWO1.ID_WORK_ORDER, TWO2.NO_ASSIGNED_TIME
				FROM T_WORK_ORDER TWO1
					INNER JOIN T_WORK_ORDER TWO2
						ON TWO1.NO_LINE > TWO2.NO_LINE	-- TO GET ALL PREVIOUS WORK ORDERS ASSIGNED TIME
						AND TWO1.ID_PRODUCTION_LINE = TWO2.ID_PRODUCTION_LINE -- AND ONLY FOR THE PRODUCTION LINE
				--ORDER BY TWO1.ID_PRODUCTION_LINE, TWO1.NO_LINE, TWO2.NO_LINE
			), T_TOTAL_PREVIOUS_ASSIGNED_TIME AS (
				SELECT TPAT.ID_WORK_ORDER, SUM(TPAT.NO_ASSIGNED_TIME) AS NO_TOTAL_PREVIOUS_ASSIGNED_TIME
				FROM T_PREVIOUS_ASSIGNED_TIME TPAT
				GROUP BY TPAT.ID_WORK_ORDER
			)

	--		SELECT * 
			UPDATE TWO
				SET DT_WORK_ORDER = DATEADD(MINUTE, TTPAT.NO_TOTAL_PREVIOUS_ASSIGNED_TIME, TWO.DT_WORK_ORDER)
			FROM #T_WORKORDER TWO
				INNER JOIN T_TOTAL_PREVIOUS_ASSIGNED_TIME TTPAT
					ON TWO.ID_WORK_ORDER = TTPAT.ID_WORK_ORDER

			INSERT INTO PRD.K_WORK_ORDER (
				ID_WORK_ORDER
				, KY_CUSTOMER	
				, NM_CUSTOMER	
				, NO_WORK_ORDER	
				, NO_PRODUCTION_TIME
				, NO_TRANSITIONS_TIME
				, NO_STANDARD_TIME	
				, ID_ITEM	
				, NM_ITEM	
				, ID_BRANCH_PLANT	
				, ID_PRODUCTION_LINE	
				, NM_PRODUCTION_LINE	
				, DT_WORK_ORDER	
				, NO_RUN_QTY	
				, NO_BOX_QTY	
				, NM_MATERIAL	
				, NM_COLOR	
				, NO_LENGHT	
				, NO_WIDTH	
				, NO_THICKNESS	
				, NO_POUNDS	
				, KY_PACKAGE	
				, PACKED	
				, DT_REQ_DATE	
				, NO_ORDER	
				, NO_SEQ	
				, NO_HRS_LABOR_MACHINE	
				, NO_QTY_SKID	
				, DT_ORDER	
				, NO_SHIPING_WEIGHT_PER_HR	
				, KY_UPC	
				, KY_STATUS	
				, DT_CREATION	
				, KY_USER_APP_CREATION	
				, NM_PROGAM_CREATE	
			)
			SELECT TWO.ID_WORK_ORDER
				, TWO.KY_CUSTOMER
				, TWO.NM_CUSTOMER
				, TWO.NO_WORK_ORDER
				, TWO.NO_PRODUCTION_TIME
				, TWO.NO_TRANSITIONS_TIME
				, TWO.NO_PRODUCTION_TIME + TWO.NO_TRANSITIONS_TIME
				, TWO.ID_ITEM
				, TWO.NM_ITEM
				, TWO.ID_BRANCH_PLANT
				, TWO.ID_PRODUCTION_LINE
				, TWO.NM_PRODUCTION_LINE
				, TWO.DT_WORK_ORDER
				, TWO.NO_RUN_QTY
				, ISNULL(TWO.NO_BOX_QTY, 0)
				, TWO.NM_MATERIAL
				, TWO.NM_COLOR
				, ISNULL(TWO.NO_LENGHT, 0)
				, ISNULL(TWO.NO_WIDTH, 0)
				, ISNULL(TWO.NO_THICKNESS, 0)
				, TWO.NO_POUNDS
				, TWO.KY_PACKAGE
				, TWO.PACKED
				, TWO.DT_REQ_DATE
				, TWO.NO_ORDER
				, TWO.NO_SEQ
				, TWO.NO_HRS_LABOR_MACHINE
				, TWO.NO_QTY_SKID
				, TWO.DT_ORDER
				, TWO.NO_SHIPING_WEIGHT_PER_HR
				, TWO.KY_UPC
				, TWO.KY_STATUS
				, @DT_SYSTEM
				, @PIN_KY_USER
				, @PIN_NM_PROGRAM
			FROM #T_WORKORDER TWO
			ORDER BY TWO.ID_PRODUCTION_LINE, TWO.NO_SEQ

			INSERT INTO PRD.K_WORK_ORDER_TRANSITIONS (ID_WORK_ORDER
				, ID_TRANSITION	
				, KY_TRANSITION	
				, NM_TRANSITION	
				, NO_STANDARD_TIME	
				, DT_CREATION	
				, KY_USER_APP_CREATION	
				, NM_PROGAM_CREATE	
			)
			SELECT TT.ID_WORK_ORDER
				, TT.ID_TRANSITION
				, CT.KY_TRANSITION
				, CT.NM_TRANSITION
				, CT.NO_STANDARD_TIME
				, @DT_SYSTEM
				, @PIN_KY_USER
				, @PIN_NM_PROGRAM
			FROM PRD.C_TRANSITION CT
				INNER JOIN #T_TRANSITION TT
					ON CT.ID_TRANSITION = TT.ID_TRANSITION
			
			-- The sequence of scheduled work orders and skipped work orders is updated
			-- ========================================================================
			CREATE TABLE #T_WORK_ORDER (
				ID_WORK_ORDER INT
				, NO_SEQUENCE INT
			)

			INSERT INTO #T_WORK_ORDER (ID_WORK_ORDER, NO_SEQUENCE)
			SELECT *
FROM OPENQUERY(JDEPROD, 'SELECT W.WADOCO AS ID_WORK_ORDER
				, W.WARESC AS NO_SEQ
			FROM PRODDTA.F4801 W ' ) W WHERE EXISTS (SELECT TOP 1 1 FROM PRD.K_WORK_ORDER KWO WHERE KWO.ID_WORK_ORDER = W.ID_WORK_ORDER AND KWO.KY_STATUS IN ('SCHEDULED', 'SKIPPED'))
			UPDATE KWO 
			SET NO_ORDER = TWO.NO_SEQUENCE
				, NO_SEQ = TWO.NO_SEQUENCE
			FROM PRD.K_WORK_ORDER KWO
				INNER JOIN #T_WORK_ORDER TWO
					ON KWO.ID_WORK_ORDER = TWO.ID_WORK_ORDER
			-- ========================================================================

		END ELSE BEGIN
			-- WE UPDATE THE REGISTER ON THE TABLE

			UPDATE U
			SET

							U.	KY_CUSTOMER	 =d.value('@KY_CUSTOMER', 'nvarchar(50)')
						   ,U.	NM_CUSTOMER	=d.value('@NM_CUSTOMER', 'nvarchar(200)')
						   ,U.	NO_WORK_ORDER	=d.value('@NO_WORK_ORDER', 'INT')
						   , U.	NO_PRODUCTION_TIME = d.value('@NO_ASSIGNED_TIME', 'INT')
						   ,U.	ID_ITEM	=d.value('@ID_ITEM', 'INT')
						   ,U.	NM_ITEM	=d.value('@NM_ITEM', 'nvarchar(100)')
						   ,U.	ID_BRANCH_PLANT	=d.value('@ID_BRANCH_PLANT', 'INT')
						   ,U.	ID_PRODUCTION_LINE	=d.value('@ID_PRODUCTION_LINE', 'INT')
						   ,U.	NM_PRODUCTION_LINE	=d.value('@NM_PRODUCTION_LINE', 'nvarchar(300)')
						   ,U.	NO_RUN_QTY	=d.value('@NO_RUN_QTY', 'int')
						   ,U.	NO_BOX_QTY	=d.value('@NO_BOX_QTY', 'int')
						   ,U.	NM_MATERIAL	=d.value('@NM_MATERIAL', 'nvarchar(200)')
						   ,U.	NM_COLOR	=d.value('@NM_COLOR', 'nvarchar(100)')
						   ,U.	NO_LENGHT	=d.value('@NO_LENGHT', 'FLOAT')
						   ,U.	NO_WIDTH	=d.value('@NO_WIDTH', 'FLOAT')
						   ,U.	NO_THICKNESS	=d.value('@NO_THICKNESS', 'FLOAT')

						   	,U.	NO_POUNDS	 =d.value('@NO_POUNDS', 'FLOAT')
							,U.	KY_PACKAGE	= d.value('@KY_PACKAGE', 'NVARCHAR(50)')
							,U.	PACKED	=d.value('@PACKED', 'INT')
							,U.	DT_REQ_DATE	= d.value('@DT_REQ_DATE', 'DATETIME')
							,U.	NO_ORDER	= d.value('@NO_ORDER', 'INT')
							,U.	NO_SEQ	= d.value('@NO_SEQ', 'INT')
							,U.	NO_HRS_LABOR_MACHINE	= d.value('@NO_HRS_LABOR_MACHINE', 'INT')
							,U.	NO_QTY_SKID	= d.value('@NO_QTY_SKID', 'NVARCHAR(50)') 
							,U.	DT_ORDER	=d.value('@DT_ORDER', 'DATETIME')
							,U.	NO_SHIPING_WEIGHT_PER_HR	= d.value('@NO_SHIPING_WEIGHT_PER_HR', 'FLOAT')
							,U.	KY_UPC	= d.value('@KY_UPC', 'NVARCHAR(20)')
							,U.	KY_STATUS	= d.value('@KY_STATUS', 'NVARCHAR(50)')

						, U.	DT_UPDATE	 =@DT_SYSTEM
						, U.	KY_USER_APP_UPDATE	 = @PIN_KY_USER
						, U.	NM_PROGRAM_UPDATE	 = @PIN_NM_PROGRAM
			--WHERE 	ID_WORK_ORDER	 = @PIN_ID_WORK_ORDER
			FROM 	PRD	.	K_WORK_ORDER	 U
			INNER JOIN @PIN_XML_WORK_ORDERS.nodes('WORKORDERS/WORKORDER') AS T(d)
			ON  U.ID_WORK_ORDER = d.value('@ID_WORK_ORDER', 'INT')						


		END
		-- WE BACK A RETURN VARIABLE THAT INDICATES ALL WAS PERFORMED OKAY 
		SET @XML_RESULT = DBO.F_ERROR_CREATE_HEADER( @@ROWCOUNT, 1, 'SUCCESSFUL')
		SET @XML_RESULT = DBO.F_ERROR_INSERT_MESSAGES(@XML_RESULT, 'Proceso exitoso', 'ES')
		SET @XML_RESULT = DBO.F_ERROR_INSERT_MESSAGES(@XML_RESULT, 'Successful Process', 'EN')
		-- IF THERE IS A TRANSACTION IN THIS BLOCK, IT WILL BE ERASED
		IF (@@TRANCOUNT > 0 AND @V_EXIST_TRAN = 1)
			COMMIT	

	END TRY
	BEGIN CATCH		
		--IF IT OCCURS A ERROR IN THIS BLOCK THE TRANSACTIO GET CANCELED
		IF (@@TRANCOUNT > 0 AND @V_EXIST_TRAN = 1)
			ROLLBACK
			
		DECLARE @KY_ERROR INT  = 	ERROR_NUMBER()
		DECLARE @ERROR_MESSAGE NVARCHAR(250)  = 	 ERROR_MESSAGE()
	SELECT @ERROR_MESSAGE 
	    SET @XML_RESULT = DBO.F_ERROR_CREATE_HEADER( @@ROWCOUNT, @KY_ERROR, 'ERROR')
		SET @XML_RESULT = DBO.F_ERROR_MESSAGES( @KY_ERROR,'Ocurrió un error al procesar el registro')
		SET @XML_RESULT = DBO.F_ERROR_MESSAGES( @KY_ERROR, 'There was an error processing the register' + ' ' + @ERROR_MESSAGE)
		
		EXEC ADM.SPE_RAISE_ERROR
			
	END CATCH
END
