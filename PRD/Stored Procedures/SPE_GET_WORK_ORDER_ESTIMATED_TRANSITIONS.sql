-- =============================================
-- Proyecto: Plaskolite
-- Copyright (c) - Acrux - 2018
-- Author: Gabriel Vázquez Torres
-- CREATE date: 07/06/2018
-- Description: Get the transition of a work order depend on the previous work order
-- =============================================
CREATE PROCEDURE  [PRD].[SPE_GET_WORK_ORDER_ESTIMATED_TRANSITIONS]
	-- Add the parameters for the stored procedure here
	@PIN_ID_PRODUCTION_LINE AS INT
AS
BEGIN

	DECLARE @V_ID_BRANCH_PLANT AS INT

	CREATE TABLE #TB_WORK_ORDERS (
		ID_WORK_ORDER INT,
		ID_BRANCH_PLANT INT,
		ID_ITEM INT,
		NO_ORDER INT,
		KY_ORIGN NVARCHAR(50)
	)

	CREATE TABLE #TB_WORK_ORDER_CHARACTERISTICS (
		ID_WORK_ORDER INT,
		ID_ITEM INT,
		NO_ORDER INT,
		KY_ORIGN NVARCHAR(50),
		ID_NEXT_ITEM INT,
		ID_METRIC_NEXT_ITEM INT,
		NO_VALUE_NEXT_ITEM NVARCHAR(100),
		NO_VALUE_CURRENT_ITEM NVARCHAR(100) NULL,
		FG_VALUE_CHANGE BIT NULL
	)

	CREATE TABLE #T_TRANSITIONS (

		ID_WORK_ORDER		INT, 
		ID_TRANSITION		INT,
		KY_TRANSITION		NVARCHAR(50),
		NM_TRANSITION		NVARCHAR(100), 
		NO_STANDARD_TIME	INT, 
		DS_TRANSITION		NVARCHAR(200), 
		FG_ACTIVE			BIT,
		KY_ACTIVE			NVARCHAR(50)

	)

	SELECT @V_ID_BRANCH_PLANT = ID_BRANCH_PLANT FROM PRD.C_PRODUCTION_LINE WHERE ID_PRODUCTION_LINE = @PIN_ID_PRODUCTION_LINE

	-- obtenemos la última orden de trabajo planeada de la línea de producción
	INSERT INTO #TB_WORK_ORDERS
	SELECT TOP 1 ID_WORK_ORDER, @V_ID_BRANCH_PLANT, ID_ITEM, NO_ORDER, 'SCHEDULED'
	FROM PRD.K_WORK_ORDER
	WHERE ID_PRODUCTION_LINE = @PIN_ID_PRODUCTION_LINE AND KY_STATUS = 'SCHEDULED'
	ORDER BY NO_ORDER


	--Obtenemos las órdenes de trabajo que se pueden importar de JDEWARDS
	INSERT INTO #TB_WORK_ORDERS
	SELECT ID_WORK_ORDER, @V_ID_BRANCH_PLANT, ID_ITEM, NO_ORDER, 'JDEDWARDS'
	FROM PRD.VW_K_WORK_ORDER_JDEDWARDS VKWOJ
	WHERE CL_STATUS = '45' AND ID_PRODUCTION_LINE = @PIN_ID_PRODUCTION_LINE AND NOT EXISTS (SELECT TOP 1 1 FROM PRD.K_WORK_ORDER KWO WHERE VKWOJ.ID_WORK_ORDER = KWO.ID_WORK_ORDER)
	ORDER BY NO_SEQ, DT_REQ_DATE DESC

	-- Obtenemos las caracteristicas y el valor nominal de cada una de ellas del item de la siguiente orden de trabajo
	INSERT #TB_WORK_ORDER_CHARACTERISTICS(ID_WORK_ORDER, ID_ITEM, NO_ORDER, KY_ORIGN, ID_NEXT_ITEM, ID_METRIC_NEXT_ITEM, NO_VALUE_NEXT_ITEM)
	SELECT T1.ID_WORK_ORDER, T1.ID_ITEM, T1.NO_ORDER, T1.KY_ORIGN, T1.ID_NEXT_ITEM, I2C.ID_METRICS, I2C.XML_FIELD_SETTINGS.value('(/SETTINGS/FIELD_TYPES/@NOMINAL_VALUE)[1]','nvarchar(100)') AS NO_VALUE
	FROM (
		SELECT ID_WORK_ORDER, ID_ITEM, NO_ORDER, KY_ORIGN, LAG(ID_ITEM, 1, 0) OVER(ORDER BY NO_ORDER) AS ID_NEXT_ITEM
		FROM #TB_WORK_ORDERS
		) AS T1
	INNER JOIN PRD.C_ITEM_CHARACTERISTIC I2C ON T1.ID_NEXT_ITEM = I2C.ID_ITEM

	-- Actualizamos el valor de las caracteristicas del item actual de la orden de compra
	UPDATE #TB_WORK_ORDER_CHARACTERISTICS
		SET NO_VALUE_CURRENT_ITEM = T1.NO_VALUE
	FROM (
		SELECT WOC.ID_WORK_ORDER AS ID_WORK_ORDER_1, WOC.ID_ITEM AS ID_ITEM_1, WOC.NO_ORDER AS NO_ORDER_1, WOC.KY_ORIGN AS KY_ORIGN_1, WOC.ID_NEXT_ITEM AS ID_NEXT_ITEM_1, WOC.ID_METRIC_NEXT_ITEM AS ID_METRIC_NEXT_ITEM_1, WOC.NO_VALUE_NEXT_ITEM, I1C.XML_FIELD_SETTINGS.value('(/SETTINGS/FIELD_TYPES/@NOMINAL_VALUE)[1]','nvarchar(100)') AS NO_VALUE
		FROM #TB_WORK_ORDER_CHARACTERISTICS WOC
			LEFT JOIN PRD.C_ITEM_CHARACTERISTIC I1C ON WOC.ID_ITEM = I1C.ID_ITEM AND WOC.ID_METRIC_NEXT_ITEM = I1C.ID_METRICS
		) AS T1
	WHERE ID_WORK_ORDER = T1.ID_WORK_ORDER_1 AND ID_ITEM = T1.ID_ITEM_1 AND ID_NEXT_ITEM = T1.ID_NEXT_ITEM_1 AND ID_METRIC_NEXT_ITEM = T1.ID_METRIC_NEXT_ITEM_1
	

	-- Actualizamos si cambia el valor de un item a otro
	UPDATE #TB_WORK_ORDER_CHARACTERISTICS
		SET FG_VALUE_CHANGE = CASE WHEN NO_VALUE_NEXT_ITEM = NO_VALUE_CURRENT_ITEM THEN 0 ELSE 1 END

	
	INSERT INTO #T_TRANSITIONS
	SELECT DISTINCT ID_WORK_ORDER, CT.ID_TRANSITION, CT.KY_TRANSITION, CT.NM_TRANSITION, CT.NO_STANDARD_TIME, CT.DS_TRANSITION, CT. FG_ACTIVE, CASE WHEN CT.FG_ACTIVE = 1 THEN 'Yes' ELSE 'No' END AS KY_ACTIVE
	FROM #TB_WORK_ORDER_CHARACTERISTICS WOC
		INNER JOIN PRD.C_METRICS_TRANSITION CMT ON WOC.ID_METRIC_NEXT_ITEM = CMT.ID_METRICS
		INNER JOIN PRD.C_TRANSITION CT ON CMT.ID_TRANSITION = CT.ID_TRANSITION
	WHERE WOC.FG_VALUE_CHANGE = 1 AND  CT.FG_ACTIVE = 1
	ORDER BY WOC.ID_WORK_ORDER


	;WITH T_ITEMS_DIFERENCE AS (

		SELECT ID_WORK_ORDER, ID_BRANCH_PLANT, ID_ITEM, NO_ORDER, KY_ORIGN, ID_NEXT_ITEM, SUBSTRING(CAST(ID_ITEM AS NVARCHAR),1,3) AS ID_ITEM3, SUBSTRING(CAST(ID_NEXT_ITEM AS NVARCHAR),1,3) AS ID_NEXT_ITEM3
		FROM (
			SELECT ID_WORK_ORDER, ID_BRANCH_PLANT, ID_ITEM, NO_ORDER, KY_ORIGN, LAG(ID_ITEM, 1, 0) OVER(ORDER BY NO_ORDER) AS ID_NEXT_ITEM
			FROM #TB_WORK_ORDERS
			) AS T1
	)

	INSERT INTO #T_TRANSITIONS
	SELECT TID.ID_WORK_ORDER, CT.ID_TRANSITION, CT.KY_TRANSITION, CT.NM_TRANSITION, CT.NO_STANDARD_TIME, CT.DS_TRANSITION, CT.FG_ACTIVE, CASE WHEN CT.FG_ACTIVE = 1 THEN 'Yes' ELSE 'No' END AS KY_ACTIVE
	FROM T_ITEMS_DIFERENCE TID
		INNER JOIN ADM.C_BRANCH_PLANT_TRANSITION BPT ON TID.ID_BRANCH_PLANT = BPT.ID_BRANCH_PLANT
		INNER JOIN PRD.C_TRANSITION CT ON BPT.ID_TRANSITION = CT.ID_TRANSITION
	WHERE ID_NEXT_ITEM != 0 AND (ID_ITEM3 != ID_NEXT_ITEM3) AND NOT EXISTS(SELECT TOP 1 1 FROM #T_TRANSITIONS TT WHERE TT.ID_TRANSITION = BPT.ID_TRANSITION AND TID.ID_WORK_ORDER = TT.ID_WORK_ORDER)


	SELECT 
		ID_WORK_ORDER, 
		ID_TRANSITION, 
		KY_TRANSITION, 
		NM_TRANSITION, 
		NO_STANDARD_TIME, 
		DS_TRANSITION, 
		FG_ACTIVE, 
		KY_ACTIVE
	FROM #T_TRANSITIONS

END
