-- ================================================================
-- Proyecto: Plaskolite v2
-- Copyright (c) - Vitek - 2020
-- Author: Cynthia Aideé Alvarez.
-- CREATE date: 01/15/2020
-- Description: GET SHIFT_FOREMAN BY THE SHIFT TIME TABLE.
-- =================================================================
CREATE PROCEDURE   [PRD].[SPE_GET_SHIFT_FOREMAN]
		@RETURN_VALUE INT  = '' OUT,
	    @PIN_KY_USER       VARCHAR(80) = NULL
	  , @PIN_KY_SHIFT_TIME VARCHAR(80) = NULL
AS
BEGIN
/* 
 PASOS:
 1. COMO NO QUEREMOS QUE SE REPITAN, DEBERÍA CONSULTAR A LA MISMA TABLA SI YA ESTÁ ESE FOREMAN.
	PARA ESO, NECESITO SABER EL TURNO QUE LE TOCA Y HACER UNA COMPARACION DE FECHAS. 
 2. SI NO ESTÁ, ENTONCES NO HAGAS NADA O MANDA UN MENSAJITO.
*/
-- EN CASO DE QUE DEVUELVA UN NULO AQUÍ, SIGNIFICA QUE NO HAY NADA. SE PROCEDE A INGRESARLO.



	-- VARIABLES AUXILIARES PARA CONSULTAR LA  TABLA SHIFT_FOREMAN.
				DECLARE @FOREMAN      NVARCHAR(80) = NULL
				        , @DT_FOREMAN DATETIME
						, @DT_ACTUAL  DATETIME = CONVERT (DATE, GETDATE())
						, @DT_1       DATETIME
						, @DT_2       DATETIME
				       -- , @PIN_KY_USER        NVARCHAR(80) = 'ARAYNOR' -- HELPER
				       -- , @PIN_KY_SHIFT_TIME  VARCHAR(100) = 'SF-2' --HELPER
			-- NECESITO SABER SU SHIFT PARA HACER COMPARACIÓN CON EL DATE ACTUAL.


			IF(@PIN_KY_SHIFT_TIME IS NULL)
BEGIN
SELECT @PIN_KY_SHIFT_TIME = KY_SHIFT  FROM ADM.VW_C_SHIFT  WHERE 
CONVERT(TIME, GETDATE()) BETWEEN INITIAL_SHIFT_TIME AND  FINAL_SHIFT_TIME
END 
				DECLARE @INIT_TIME AS TIME = (SELECT INITIAL_SHIFT_TIME FROM ADM.VW_C_SHIFT
												WHERE KY_SHIFT = @PIN_KY_SHIFT_TIME)
                DECLARE @END_TIME AS TIME = (SELECT FINAL_SHIFT_TIME FROM ADM.VW_C_SHIFT
												WHERE KY_SHIFT = @PIN_KY_SHIFT_TIME)
-- SELECT @INIT_TIME, @END_TIME, @PIN_KY_SHIFT_TIME, @DT_ACTUAL -- SELECCION DE HORA (PRUEBA).

			-- LE PASAMOS A LAS FECHAS INIT Y ENDT LOS INIT_TIME Y END_TIME.
				SET @DT_1 = CONVERT(DATETIME, @DT_ACTUAL) + CONVERT(DATETIME, @INIT_TIME)
				SET @DT_2 = CONVERT(DATETIME, @DT_ACTUAL) + CONVERT(DATETIME, @END_TIME)

SELECT @PIN_KY_SHIFT_TIME, @DT_1 INIT_TIME, @DT_2 END_TIME, GETDATE() FECHA_HOY, DATEDIFF (MINUTE,@DT_1, @DT_2 ) RANGO -- COMPROBACION DE RANGOS (PRUEBA).
			 
				-- HACEMOS UN SELECT PARA SABER SI ESTÁ EL FOREMAN, Y SE ORDENA POR FECHA. 
				      SELECT TOP 1
				               @FOREMAN = KY_USER
							  ,@DT_FOREMAN = DT_SYSTEM
					   FROM PRD.K_SHIFT_FOREMAN WHERE KY_USER = @PIN_KY_USER 
					   ORDER BY DT_SYSTEM DESC
					   SELECT @FOREMAN FOREMAN, @DT_FOREMAN FECHA_SISTEMA

				-- HAY QUE VERIFICAR SI NO HAY NADA NULO PARA EVITAR ERRORES EN EL REGRESO.
					IF (@PIN_KY_SHIFT_TIME IS NOT NULL AND (@PIN_KY_USER IS NOT NULL))
						BEGIN
								IF(@DT_FOREMAN >= @DT_1 AND @DT_FOREMAN <= @DT_2)
								BEGIN
								SET @RETURN_VALUE = 1 
								RETURN @RETURN_VALUE -- REGRESO 1 PARA SABER SI ESTÁ DENTRO. NO ES NECESARIO VOLVERLO A INGRESAR.
								--	SELECT @FOREMAN AS FOREMAN, @DT_FOREMAN DT, @PIN_STATUS STATUS -- SELECT DE PRUEBA
								END
								ELSE
								BEGIN
								SET @RETURN_VALUE = 0
								RETURN @RETURN_VALUE -- REGRESO 0, SIGNIFICA QUE ES LA PRIMERA VEZ QUE ENTRA. LLAMAR AL OTRO SPE.
								END
						END
END
