-- =============================================
-- Proyecto: Plaskolite
-- Copyright (c) - Acrux - 2017
-- Author: Javier Diaz Barron
-- CREATE date: 11/05/2017
-- Description: Get the time of events of a  work Order
-- =============================================
-- Author: Gabriel Vázquez Torres
-- CREATE date: 20/07/2018
-- Description: Restructuration of SP
-- =============================================
CREATE PROCEDURE    [PRD].[SPE_GET_EVENTS_TIME_TABLE]	
	  @PIN_ID_WORK_ORDER INT 
	 ,@PIN_DT_INITIAL_DATE AS DATETIME = NULL

AS   
BEGIN
	
	DECLARE 
		@ID_PRODUCTION_LINE INT,
		@V_DT_START_WORK_ORDER AS DATETIME,
		@V_DT_CLOSE_WORK_ORDER AS DATETIME,
		@PIN_DT_FINAL_DATE DATETIME
		, @DT_SYSTEM DATETIME = GETDATE()
		, @DT_SIX_HOURS_BEFORE DATETIME


	-- OBTENEMOS LA LÍNEA DE PRODUCCIÓN Y LA FECHA DE INICIO y FIN DE LA WORK ORDER
	SELECT @ID_PRODUCTION_LINE = ID_PRODUCTION_LINE, @V_DT_START_WORK_ORDER = DT_START_WORK_ORDER, @V_DT_CLOSE_WORK_ORDER = DT_CLOSE_WORK_ORDER
	FROM PRD.K_WORK_ORDER 
	WHERE ID_WORK_ORDER = @PIN_ID_WORK_ORDER

	-- SI LA FECHA INICIAL ES NULA, TOMA LA FECHA INICIAL DEL SHIFT CORRESPONDIENTE A LA HORA ACTUAL
	IF @PIN_DT_INITIAL_DATE IS NULL	BEGIN
		SET @DT_SIX_HOURS_BEFORE = DATEADD(HOUR, -6, @DT_SYSTEM)
		SET @PIN_DT_INITIAL_DATE = DATETIMEFROMPARTS(YEAR(@DT_SIX_HOURS_BEFORE), MONTH(@DT_SIX_HOURS_BEFORE), DAY(@DT_SIX_HOURS_BEFORE), DATEPART(HOUR, @DT_SIX_HOURS_BEFORE), 0, 0, 0)
		--SELECT  
		--	@PIN_DT_INITIAL_DATE =CAST(CAST(GETDATE() AS DATE) AS NVARCHAR(10)) + ' ' + VS.INITIAL_SHIFT_TIME
		--FROM ADM.VW_C_SHIFT VS
		--WHERE
		--(VS.INITIAL_SHIFT_TIME > VS.FINAL_SHIFT_TIME AND CAST(GETDATE() AS TIME) BETWEEN VS.INITIAL_SHIFT_TIME AND  '23:59:59') OR 
		--(VS.INITIAL_SHIFT_TIME > VS.FINAL_SHIFT_TIME AND CAST(GETDATE() AS TIME) BETWEEN '00:00:00' AND VS.FINAL_SHIFT_TIME )OR 
		--(CAST(GETDATE() AS TIME) BETWEEN VS.INITIAL_SHIFT_TIME AND VS.FINAL_SHIFT_TIME)			
	END
   	
	--OBTIENE LA FECHA FINAL DEL SHIFT
	SELECT TOP 1 @PIN_DT_FINAL_DATE=DATEADD(HOUR,CAST(NO_SHIFT_TIME AS INT),@PIN_DT_INITIAL_DATE) FROM ADM.VW_C_SHIFT 


	--RESETEAMOS LAS FECHAS DE INICIO Y FIN SEGÚN LAS FECHAS DE LA WORK ORDER
	IF @V_DT_START_WORK_ORDER > @PIN_DT_INITIAL_DATE
		SET @PIN_DT_INITIAL_DATE = @V_DT_START_WORK_ORDER

	IF @V_DT_CLOSE_WORK_ORDER IS NOT NULL AND @V_DT_CLOSE_WORK_ORDER < @PIN_DT_FINAL_DATE
		SET @PIN_DT_FINAL_DATE = @V_DT_CLOSE_WORK_ORDER

	IF @V_DT_CLOSE_WORK_ORDER IS NULL AND GETDATE() < @PIN_DT_FINAL_DATE
		SET @PIN_DT_FINAL_DATE = GETDATE()    
        
   	 DECLARE @TB_EVENTS TABLE (
		ID_WORK_ORDER INT
		, EVENT NVARCHAR (10)
		, DT_INICIO DATETIME
		, DT_FIN DATETIME
	)

	--********* LT_SETUP *********
	INSERT INTO @TB_EVENTS
	SELECT
		 ID_WORK_ORDER
		,'LT_SETUP' EVENT
		,CASE WHEN DT_ISSUE < @PIN_DT_INITIAL_DATE THEN @PIN_DT_INITIAL_DATE ELSE DT_ISSUE END
		,CASE 
			WHEN DT_ISSUE_CLOSED IS NULL THEN @PIN_DT_FINAL_DATE
			WHEN DT_ISSUE_CLOSED IS NOT NULL AND DT_ISSUE_CLOSED > @PIN_DT_FINAL_DATE THEN @PIN_DT_FINAL_DATE
			ELSE DT_ISSUE_CLOSED END
	FROM PRD.K_ISSUE KI
		INNER JOIN PRD.C_PROBLEM_CODE PC 
			ON PC.ID_PROBLEM_CODE = KI.ID_PROBLEM_CODE
		INNER JOIN ADM.VW_C_CODE_TYPE CT 
			ON CT.KY_CODE_TYPE = PC.KY_CODE_TYPE
	WHERE ID_WORK_ORDER=@PIN_ID_WORK_ORDER AND 
		CT.KY_CODE_TYPE IN ('DCHG','OTHER','RCHG') AND
		KI.FG_LINE_DOWN = 0 AND		
		(
			KI.DT_ISSUE BETWEEN @PIN_DT_INITIAL_DATE AND @PIN_DT_FINAL_DATE OR 
			KI.DT_ISSUE_CLOSED BETWEEN @PIN_DT_INITIAL_DATE AND @PIN_DT_FINAL_DATE OR
			(KI.DT_ISSUE < @PIN_DT_INITIAL_DATE AND KI.DT_ISSUE_CLOSED IS NULL) OR
			(KI.DT_ISSUE < @PIN_DT_INITIAL_DATE AND KI.DT_ISSUE_CLOSED > @PIN_DT_FINAL_DATE)
		)


	--********* ISSUE *********
	INSERT INTO @TB_EVENTS
	SELECT 
		 ID_WORK_ORDER
		,'ISSUE' EVENT
		,CASE WHEN DT_ISSUE < @PIN_DT_INITIAL_DATE THEN @PIN_DT_INITIAL_DATE ELSE DT_ISSUE END
		,CASE 
			WHEN DT_ISSUE_CLOSED IS NULL THEN @PIN_DT_FINAL_DATE
			WHEN DT_ISSUE_CLOSED IS NOT NULL AND DT_ISSUE_CLOSED > @PIN_DT_FINAL_DATE THEN @PIN_DT_FINAL_DATE
			ELSE DT_ISSUE_CLOSED END
	FROM PRD.K_ISSUE KI
	INNER JOIN PRD.C_PROBLEM_CODE PC ON PC.ID_PROBLEM_CODE = KI.ID_PROBLEM_CODE
	INNER JOIN ADM.VW_C_CODE_TYPE CT ON CT.KY_CODE_TYPE = PC.KY_CODE_TYPE
	WHERE 
		ID_WORK_ORDER = @PIN_ID_WORK_ORDER AND
		CT.KY_CODE_TYPE NOT IN ('DCHG','OTHER','RCHG') AND
		KI.FG_LINE_DOWN = 0 AND
		(
			KI.DT_ISSUE BETWEEN @PIN_DT_INITIAL_DATE AND @PIN_DT_FINAL_DATE OR 
			KI.DT_ISSUE_CLOSED BETWEEN @PIN_DT_INITIAL_DATE AND @PIN_DT_FINAL_DATE OR
			(KI.DT_ISSUE < @PIN_DT_INITIAL_DATE AND KI.DT_ISSUE_CLOSED IS NULL) OR
			(KI.DT_ISSUE < @PIN_DT_INITIAL_DATE AND KI.DT_ISSUE_CLOSED > @PIN_DT_FINAL_DATE)
		)


	--********* LINE DOWN *********
	INSERT INTO @TB_EVENTS
	SELECT 
		 ID_WORK_ORDER
		,'DOWN' EVENT
		,CASE WHEN DT_ISSUE < @PIN_DT_INITIAL_DATE THEN @PIN_DT_INITIAL_DATE ELSE DT_ISSUE END
		,CASE 
			WHEN DT_ISSUE_CLOSED IS NULL THEN @PIN_DT_FINAL_DATE
			WHEN DT_ISSUE_CLOSED IS NOT NULL AND DT_ISSUE_CLOSED > @PIN_DT_FINAL_DATE THEN @PIN_DT_FINAL_DATE
			ELSE DT_ISSUE_CLOSED END
	FROM PRD.K_ISSUE KI
	INNER JOIN PRD.C_PROBLEM_CODE PC ON PC.ID_PROBLEM_CODE = KI.ID_PROBLEM_CODE
	INNER JOIN ADM.VW_C_CODE_TYPE CT ON CT.KY_CODE_TYPE = PC.KY_CODE_TYPE
	WHERE 
		ID_WORK_ORDER = @PIN_ID_WORK_ORDER AND
		KI.FG_LINE_DOWN = 1 AND
		(
			KI.DT_ISSUE BETWEEN @PIN_DT_INITIAL_DATE AND @PIN_DT_FINAL_DATE OR 
			KI.DT_ISSUE_CLOSED BETWEEN @PIN_DT_INITIAL_DATE AND @PIN_DT_FINAL_DATE OR
			(KI.DT_ISSUE < @PIN_DT_INITIAL_DATE AND KI.DT_ISSUE_CLOSED IS NULL) OR
			(KI.DT_ISSUE < @PIN_DT_INITIAL_DATE AND KI.DT_ISSUE_CLOSED > @PIN_DT_FINAL_DATE)
		)
	

	--********* READINGS *********
	-- LECTURAS QUE SON CREADAS DE UN SKID SIMULTANEO Y QUE SOLO ESTAN CREADAS
    INSERT INTO @TB_EVENTS
	SELECT
		  WO.ID_WORK_ORDER
		, 'READINGS' EVENT
		, CASE WHEN KF.DT_START < @PIN_DT_INITIAL_DATE THEN @PIN_DT_INITIAL_DATE ELSE KF.DT_START END
		, LEAD(KF.DT_START) OVER(ORDER BY KF.ID_K_FORM)
	FROM PRD.K_FORM KF
		INNER JOIN PRD.K_PALLET KP ON KF.ID_PALLET = KP.ID_PALLET
		INNER JOIN PRD.C_FORM CF ON CF.ID_FORM = KF.ID_FORM
		INNER JOIN PRD.K_WORK_ORDER WO ON WO.ID_WORK_ORDER=KF.ID_WORK_ORDER
	WHERE 
		CF.KY_PROCESS ='MANUFACTURE' AND KF.KY_STATUS_FORM NOT IN ('CANCELLED', 'CAPTURED')
		AND WO.ID_WORK_ORDER = @PIN_ID_WORK_ORDER
		AND (
			  --KF.DT_FORM BETWEEN @PIN_DT_INITIAL_DATE AND @PIN_DT_FINAL_DATE
			  (KF.DT_START < @PIN_DT_FINAL_DATE)
			)
		--AND KP.NO_PALLETS_OPENED = 1
	ORDER BY KF.DT_FORM 


	-- LECTURAS QUE SON CREADAS DE UN SKID SIMULTANEO Y QUE ESTAN CAPTURADOS
    INSERT INTO @TB_EVENTS
	SELECT
		WO.ID_WORK_ORDER
		,'READINGS' EVENT
		,CASE WHEN ISNULL(KF.DT_START, KF.DT_FORM) < @PIN_DT_INITIAL_DATE THEN @PIN_DT_INITIAL_DATE ELSE ISNULL(KF.DT_START, KF.DT_FORM) END
		,CASE WHEN KF.DT_CLOSED > @PIN_DT_FINAL_DATE THEN @PIN_DT_FINAL_DATE ELSE KF.DT_CLOSED END
	FROM PRD.K_FORM KF
		INNER JOIN PRD.K_PALLET KP ON KF.ID_PALLET = KP.ID_PALLET
		INNER JOIN PRD.C_FORM CF ON CF.ID_FORM = KF.ID_FORM
		INNER JOIN PRD.K_WORK_ORDER WO ON WO.ID_WORK_ORDER=KF.ID_WORK_ORDER
	WHERE 
		CF.KY_PROCESS ='MANUFACTURE' AND KF.KY_STATUS_FORM IN ('CAPTURED')
		AND WO.ID_WORK_ORDER=@PIN_ID_WORK_ORDER
		AND (
				ISNULL(KF.DT_START, KF.DT_FORM) BETWEEN @PIN_DT_INITIAL_DATE AND @PIN_DT_FINAL_DATE OR
				KF.DT_CLOSED BETWEEN @PIN_DT_INITIAL_DATE AND @PIN_DT_FINAL_DATE OR
				(ISNULL(KF.DT_START, KF.DT_FORM) < @PIN_DT_INITIAL_DATE AND KF.DT_CLOSED > @PIN_DT_INITIAL_DATE)
			)
		--AND KP.NO_PALLETS_OPENED = 1
	ORDER BY KF.DT_FORM 

	/*
	-- LECTURAS QUE SON CREADAS DE DOS SKIDS SIMULTANEOS Y QUE SOLO ESTAN CREADOS
    INSERT INTO @TB_EVENTS
	SELECT
		WO.ID_WORK_ORDER
		,'READINGS' EVENT
		,CASE WHEN KF.DT_FORM < @PIN_DT_INITIAL_DATE THEN @PIN_DT_INITIAL_DATE ELSE KF.DT_FORM END
		, LEAD(DT_FORM) OVER(ORDER BY KF.ID_K_FORM)
	FROM PRD.K_FORM KF
		INNER JOIN PRD.K_PALLET KP ON KF.ID_PALLET = KP.ID_PALLET
		INNER JOIN PRD.C_FORM CF ON CF.ID_FORM = KF.ID_FORM
		INNER JOIN PRD.K_WORK_ORDER WO ON WO.ID_WORK_ORDER=KF.ID_WORK_ORDER
	WHERE 
		CF.KY_PROCESS ='MANUFACTURE' AND KF.KY_STATUS_FORM NOT IN ('CANCELLED', 'CAPTURED')
		AND WO.ID_WORK_ORDER=@PIN_ID_WORK_ORDER
		AND (
			  --DT_FORM BETWEEN @PIN_DT_INITIAL_DATE AND @PIN_DT_FINAL_DATE
			  (KF.DT_FORM < @PIN_DT_FINAL_DATE)
			)
		AND KP.NO_PALLETS_OPENED = 2
	ORDER BY KF.DT_FORM 


	-- LECTURAS QUE SON CREADAS DE UN SKID SIMULTANEO Y QUE ESTAN CAPTURADOS
    INSERT INTO @TB_EVENTS
	SELECT
		WO.ID_WORK_ORDER
		,'READINGS' EVENT
		,CASE WHEN KF.DT_FORM < @PIN_DT_INITIAL_DATE THEN @PIN_DT_INITIAL_DATE ELSE KF.DT_FORM END
		,CASE WHEN KF.DT_CLOSED > @PIN_DT_FINAL_DATE THEN @PIN_DT_FINAL_DATE ELSE KF.DT_CLOSED END
	FROM PRD.K_FORM KF
		INNER JOIN PRD.K_PALLET KP ON KF.ID_PALLET = KP.ID_PALLET
		INNER JOIN PRD.C_FORM CF ON CF.ID_FORM = KF.ID_FORM
		INNER JOIN PRD.K_WORK_ORDER WO ON WO.ID_WORK_ORDER=KF.ID_WORK_ORDER
	WHERE 
		CF.KY_PROCESS ='MANUFACTURE' AND KF.KY_STATUS_FORM IN ('CAPTURED')
		AND WO.ID_WORK_ORDER=@PIN_ID_WORK_ORDER
		AND (
				DT_FORM BETWEEN @PIN_DT_INITIAL_DATE AND @PIN_DT_FINAL_DATE OR
				KF.DT_CLOSED BETWEEN @PIN_DT_INITIAL_DATE AND @PIN_DT_FINAL_DATE OR
				(KF.DT_FORM < @PIN_DT_INITIAL_DATE AND KF.DT_CLOSED > @PIN_DT_FINAL_DATE)
			)
		AND KP.NO_PALLETS_OPENED = 2
	ORDER BY KF.DT_FORM 
	*/

	UPDATE @TB_EVENTS SET DT_FIN = @PIN_DT_FINAL_DATE WHERE DT_FIN IS NULL AND EVENT = 'READINGS'
	 	
	--AGREGA LOS ESPACIOS EN EL TIEMPO QUE ESTAN VACIOS COMO TIEMPO DE PRODUCCIÓN		
	--********* PRODUCTIONS *********	
	INSERT INTO @TB_EVENTS
	SELECT * FROM (
		SELECT 
			ID_WORK_ORDER
			,CASE 
				WHEN EVENT ='ISSUE' OR EVENT ='DOWN' OR EVENT = 'READINGS' OR EVENT ='LT_SETUP' THEN 'PRODUCTION' 			
			    ELSE EVENT	
			  END EVENT
			,CASE 
				WHEN EVENT ='ISSUE' OR EVENT ='DOWN' OR EVENT = 'READINGS' OR EVENT ='LT_SETUP'
					THEN  CASE 
							WHEN CAST(LAG(DT_FIN) OVER(ORDER BY DT_INICIO) AS DATE) < CAST(@PIN_DT_INITIAL_DATE AS DATE)
								THEN DT_INICIO
							ELSE
								LAG(DT_FIN) OVER(ORDER BY DT_INICIO)
						  END
				ELSE DT_INICIO 
			 END DT_INICIO
			,CASE 
				WHEN EVENT ='ISSUE' OR EVENT ='DOWN' OR EVENT = 'READINGS' OR EVENT ='LT_SETUP'
					THEN  DT_INICIO 			
				ELSE DT_FIN 
			 END DT_FIN
		FROM @TB_EVENTS 
	)T WHERE EVENT NOT IN ('START','SCHEDULED')
    ORDER BY DT_INICIO
    
    
    --******* PRODCUCTION AFTER STAR *****  
	--ESTA CONSULTA SE COMENTÓ POR QUE CAUSABA RUIDO EN LOS DATOS  
/*
    ;WITH TB_PRODUCION_AFTER_START AS 
    (
	    SELECT 
	    	
	    	*
	    	,LEAD(EVENT)  OVER(ORDER BY DT_INICIO) NEXT_EVENT
	    	,LEAD(DT_INICIO)  OVER(ORDER BY DT_INICIO) NEXT_DT_INICIO
	    	,DATEDIFF(MI,DT_FIN,LEAD(DT_INICIO)  OVER(ORDER BY DT_INICIO)) DIF_MINUTES_NEXT_EVENT	    	
	    FROM @TB_EVENTS
	)
	INSERT INTO @TB_EVENTS
	SELECT 
		ID_WORK_ORDER
		,'PRODUCTION' EVENT
		,DT_FIN DT_START
		,NEXT_DT_INICIO DT_FIN		
	 FROM TB_PRODUCION_AFTER_START 
	 WHERE DIF_MINUTES_NEXT_EVENT > 0
*/
    --SI EL PRIMERO REGISTRO ES DE PRODUCCIÓN, SE LE ACTUALIZA LA FECHA INICIAL A LA FECHA DEL PERIODO
	UPDATE @TB_EVENTS SET DT_INICIO = @PIN_DT_INITIAL_DATE WHERE DT_INICIO IS NULL AND EVENT = 'PRODUCTION'


	--CALCULAMOS EL ÚLTIMO REGISTRO DE PRODUCCIÓN
	INSERT INTO @TB_EVENTS
	SELECT * 
	FROM (
			SELECT 
				ID_WORK_ORDER  ID_WORK_ORDER
				,'PRODUCTION' EVENT
				,ISNULL((SELECT MAX(DT_FIN) FROM @TB_EVENTS), @PIN_DT_INITIAL_DATE) DT_INICIO
				,CASE 
					WHEN DT_CLOSE_WORK_ORDER  IS NULL THEN @PIN_DT_FINAL_DATE 					
					WHEN DT_CLOSE_WORK_ORDER  IS NOT NULL AND DT_CLOSE_WORK_ORDER <= @PIN_DT_FINAL_DATE THEN DT_CLOSE_WORK_ORDER ELSE @PIN_DT_FINAL_DATE
				END DT_FIN
			FROM PRD.K_WORK_ORDER 
			WHERE 
				ID_WORK_ORDER = @PIN_ID_WORK_ORDER AND 
				DT_START_WORK_ORDER IS NOT NULL
		) T


	--OBTIENE LOS EVENTOS CUYA DIFERENCIA DE TIEMPO SEA MAYOR A CERO
	;WITH TB_FINAL_CHIP AS (
		
		SELECT
			0 N
			,EVT.ID_WORK_ORDER
			,GETDATE() DT_WORK_ORDER
			,0 ID_ISSUE
			,0 ID_FORM
			,EVT.EVENT
			,EVT.DT_INICIO DT_START
			,EVT.DT_FIN DT_END
			,CASE 
				WHEN  EVT.DT_INICIO < @PIN_DT_INITIAL_DATE THEN DATEDIFF(MI, @PIN_DT_INITIAL_DATE, ISNULL(EVT.DT_FIN, @PIN_DT_INITIAL_DATE)) 
				ELSE DATEDIFF(MI, EVT.DT_INICIO, ISNULL(EVT.DT_FIN, @PIN_DT_INITIAL_DATE)) 
			 END MINUTES
			,ID_PRODUCTION_LINE
		FROM @TB_EVENTS EVT
			INNER JOIN PRD.K_WORK_ORDER WO ON WO.ID_WORK_ORDER = EVT.ID_WORK_ORDER
		WHERE 	
		CASE 
			WHEN CAST(EVT.DT_INICIO AS TIME) > CAST(EVT.DT_FIN AS TIME)
				THEN DATEDIFF(MI, EVT.DT_INICIO, CAST(CAST(EVT.DT_INICIO AS DATE) AS NVARCHAR(10)) + ' 23:59:59') + DATEDIFF(MI, CAST(CAST(EVT.DT_FIN AS DATE) AS NVARCHAR(10)) + ' 00:00:00', EVT.DT_FIN)
			ELSE
				DATEDIFF(MI, EVT.DT_INICIO, ISNULL(EVT.DT_FIN, @PIN_DT_INITIAL_DATE))
		END >= 0	
	)
	
	SELECT
		FC.N, 
		FC.ID_WORK_ORDER, 
		FC.DT_WORK_ORDER, 
		FC.ID_ISSUE, 
		FC.ID_FORM, 
		FC.EVENT, 
		FC.DT_START, 
		FC.DT_END, 		
		FC.MINUTES
	FROM TB_FINAL_CHIP FC
	WHERE MINUTES > 0
	ORDER BY DT_START


END

